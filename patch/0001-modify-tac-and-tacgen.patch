From 51c65ff0f29956ebcd942c6b66c4380a3431ff9e Mon Sep 17 00:00:00 2001
From: MashPlant <740678788@qq.com>
Date: Tue, 19 Nov 2019 11:59:51 +0800
Subject: [PATCH 1/3] modify tac and tacgen

---
 codegen/src/lib.rs        |   4 +-
 codegen/src/mips_gen.rs   |  83 +++++++++---------
 driver/src/lib.rs         |  11 ++-
 print/src/mips.rs         |  12 +--
 print/src/tac.rs          |  73 +++++++---------
 tac/src/iter.rs           |  10 +--
 tac/src/lib.rs            | 105 +++++++++--------------
 tacgen/src/lib.rs         | 171 ++++++++++++++++++--------------------
 tacopt/src/bb.rs          | 155 +++++++++++++++-------------------
 tacopt/src/common_expr.rs |  62 +++++++-------
 tacopt/src/const_prop.rs  |  29 ++++---
 tacopt/src/copy_prop.rs   |  29 +++----
 12 files changed, 336 insertions(+), 408 deletions(-)

diff --git a/codegen/src/lib.rs b/codegen/src/lib.rs
index abf11d3..86bc5f2 100644
--- a/codegen/src/lib.rs
+++ b/codegen/src/lib.rs
@@ -15,7 +15,7 @@ pub enum Reg {
 
 impl Reg {
   // no matter what kind of reg it is, this function just return its id, although their meaning may be different
-  pub fn id(&self) -> u32 {
-    match *self { Reg::PreColored(r) => r, Reg::Allocated(r) => r, Reg::Virtual(r) => r }
+  pub fn id(self) -> u32 {
+    match self { Reg::PreColored(r) => r, Reg::Allocated(r) => r, Reg::Virtual(r) => r }
   }
 }
\ No newline at end of file
diff --git a/codegen/src/mips_gen.rs b/codegen/src/mips_gen.rs
index fbba112..eee847e 100644
--- a/codegen/src/mips_gen.rs
+++ b/codegen/src/mips_gen.rs
@@ -1,15 +1,15 @@
 use crate::{graph_alloc::*, mips::{*, regs::*}, Reg, AllocMethod};
 use tacopt::{bb::{FuncBB, NextKind}, flow::{Flow, Or, FlowElem}};
-use tac::{TacKind, TacProgram, Operand, CallKind, FuncNameKind, Intrinsic};
+use tac::{Tac, TacProgram, Operand, CallKind, Intrinsic};
 use common::{HashSet, HashMap, BinOp};
 use bitset::traits::*;
 
 pub struct FuncGen<'a, 'b> {
   pub(crate) param_num: u32,
-  pub(crate) max_reg: u32,
-  // for functions that this function calls
-  pub(crate) max_param: u32,
-  pub(crate) name: FuncNameKind<'a>,
+  pub(crate) reg_num: u32,
+  // for functions that this function calls, not the parameter of this function (which is `param_num`)
+  pub(crate) ch_param_num: u32,
+  pub(crate) name: &'b str,
   pub(crate) program: &'b TacProgram<'a>,
   // we do need to insert in the SomeContainer<AsmTemplate>, but rust's LinkedList's api is so limited
   // and we do not need arbitrary insertion/deletion, so a Vec will be enough
@@ -30,7 +30,7 @@ impl AllocCtx for FuncGen<'_, '_> {
   fn initial(&self) -> (Vec<u32>, Vec<Node>) {
     // there are only ALLOC_N registers to allocate, but there are REG_N pre-colored nodes
     // (by definition, a machine register <=> a pre-colored node)
-    ((REG_N..self.max_reg + REG_N).collect(), (0..self.max_reg + REG_N).map(|r| if r < REG_N {
+    ((REG_N..self.reg_num + REG_N).collect(), (0..self.reg_num + REG_N).map(|r| if r < REG_N {
       Node::new(Reg::PreColored(r))
     } else {
       Node::new(Reg::Virtual(r))
@@ -45,8 +45,8 @@ impl AllocCtx for FuncGen<'_, '_> {
     for (off, b) in self.bb.iter().enumerate().map(|b| (b.0 * each, &(b.1).0)) {
       let live = &mut out[off..off + each];
       for t in b.iter().rev() {
-        if let AsmTemplate::Mv(w1, r1) = t {
-          let (w1, r1) = (Reg::id(w1), Reg::id(r1));
+        if let &AsmTemplate::Mv(w1, r1) = t {
+          let (w1, r1) = (w1.id(), r1.id());
           if Self::involved_in_alloc(w1) && Self::involved_in_alloc(r1) {
             live.bsdel(r1);
             allocator.nodes[w1 as usize].move_list.push((w1, r1));
@@ -55,15 +55,15 @@ impl AllocCtx for FuncGen<'_, '_> {
           }
         }
         t.rw(&mut r, &mut w);
-        for w in w.iter().map(Reg::id) {
+        for w in w.iter().cloned().map(Reg::id) {
           for l in live.bsones() {
             if Self::involved_in_alloc(w) && Self::involved_in_alloc(l) {
               allocator.add_edge(w, l);
             }
           }
         }
-        w.iter().map(Reg::id).for_each(|w| live.bsdel(w));
-        r.iter().map(Reg::id).for_each(|r| live.bsset(r));
+        w.iter().cloned().map(Reg::id).for_each(|w| live.bsdel(w));
+        r.iter().cloned().map(Reg::id).for_each(|r| live.bsset(r));
       }
     }
   }
@@ -120,10 +120,10 @@ impl AllocCtx for FuncGen<'_, '_> {
 }
 
 impl<'a: 'b, 'b> FuncGen<'a, 'b> {
-  pub fn work(f: &FuncBB<'a>, p: &'b TacProgram<'a>, m: AllocMethod) -> Vec<AsmTemplate> {
-    // max_reg is not inced by K, and new_reg() doesn't either, so all usage of virtual register id need to inc K
+  pub fn work(f: &'b FuncBB<'a>, p: &'b TacProgram<'a>, m: AllocMethod) -> Vec<AsmTemplate> {
+    // reg_num is not inced by K, and new_reg() doesn't either, so all usage of virtual register id need to inc K
     // including those using f's inst and those generated to meet calling convention
-    let mut fu = FuncGen { param_num: f.param_num, max_reg: f.max_reg, max_param: 0, name: f.name, program: p, bb: Vec::new(), spill2slot: HashMap::new() };
+    let mut fu = FuncGen { param_num: f.param_num, reg_num: f.reg_num, ch_param_num: 0, name: &f.name, program: p, bb: Vec::new(), spill2slot: HashMap::new() };
     fu.populate(f);
     match m { AllocMethod::Graph => Allocator::work(&mut fu), AllocMethod::Brute => fu.brute_alloc() }
     fu.fill_imm_tag();
@@ -140,11 +140,11 @@ impl<'a: 'b, 'b> FuncGen<'a, 'b> {
     for (idx, b1) in f.bb.iter().enumerate() {
       let mut b2 = Vec::new();
       if !(b1.prev.is_empty() || (b1.prev.len() == 1 && b1.prev[0] + 1 == idx as u32)) {
-        b2.push(AsmTemplate::Label(format!("{:?}_L{}:", self.name, idx + 1)));
+        b2.push(AsmTemplate::Label(format!("{}_L{}:", self.name, idx + 1)));
       }
       let mut arg_cnt = 0;
       for t in b1.iter() {
-        self.select_inst(t.payload.borrow().kind, &mut b2, &mut arg_cnt);
+        self.select_inst(t.tac.get(), &mut b2, &mut arg_cnt);
       }
       // generate ret/jmp/..., and return the `next` by the way
       let next = self.build_next(idx as u32, f.bb.len() as u32 + 1, b1.next, &mut b2);
@@ -165,7 +165,7 @@ impl<'a: 'b, 'b> FuncGen<'a, 'b> {
       }
     }
     // Tac::Ret should mv return value(if any) to v0 and jmp here
-    epi.push(Label(format!("{:?}_Ret:", self.name)));
+    epi.push(Label(format!("{}_Ret:", self.name)));
     for ces in CALLEE_SAVE {
       let tmp = self.new_reg();
       pro.push(Mv(vreg(tmp), Reg::PreColored(ces)));
@@ -182,20 +182,20 @@ impl<'a: 'b, 'b> FuncGen<'a, 'b> {
     r < Self::K /* an allocatable machine register */ || r >= REG_N /* an virtual register */
   }
 
-  fn new_reg(&mut self) -> u32 { (self.max_reg, self.max_reg += 1).0 }
+  fn new_reg(&mut self) -> u32 { (self.reg_num, self.reg_num += 1).0 }
 
   pub(crate) fn find_spill_slot(&mut self, vreg: u32) -> Imm {
     let vreg = vreg - REG_N;
     if vreg < self.param_num.max(ARG_N) { // function arguments already have places to spill
       Imm::Tag(vreg)
     } else {
-      let new_slot = (self.spill2slot.len() as i32 + self.max_param as i32) * WORD_SIZE;
+      let new_slot = (self.spill2slot.len() as i32 + self.ch_param_num as i32) * WORD_SIZE;
       Imm::Int(*self.spill2slot.entry(vreg).or_insert(new_slot))
     }
   }
 
   fn fill_imm_tag(&mut self) {
-    let self_stack = (self.spill2slot.len() as i32 + self.max_param as i32) * WORD_SIZE;
+    let self_stack = (self.spill2slot.len() as i32 + self.ch_param_num as i32) * WORD_SIZE;
     for (b, _) in &mut self.bb {
       for t in b {
         if let Some(imm) = t.imm_mut() {
@@ -238,7 +238,7 @@ impl<'a: 'b, 'b> FuncGen<'a, 'b> {
 impl FuncGen<'_, '_> {
   // the logic is almost the same as `aliveness.rs`
   pub fn analyze(&self) -> Flow<Or> {
-    let mut aliveness_flow = Flow::<Or>::new(self.bb.len(), (self.max_reg + REG_N) as usize);
+    let mut aliveness_flow = Flow::<Or>::new(self.bb.len(), (self.reg_num + REG_N) as usize);
     let each = aliveness_flow.each();
     let FlowElem { gen: use_, kill: def, .. } = aliveness_flow.split();
     for (idx, b) in self.bb.iter().enumerate() {
@@ -253,11 +253,11 @@ impl FuncGen<'_, '_> {
     let (mut r, mut w) = (Vec::new(), Vec::new());
     for t in b.iter().rev() {
       t.rw(&mut r, &mut w);
-      w.iter().map(Reg::id).for_each(|w| {
+      w.iter().cloned().map(Reg::id).for_each(|w| {
         def.bsset(w);
         use_.bsdel(w);
       });
-      r.iter().map(Reg::id).for_each(|r| {
+      r.iter().cloned().map(Reg::id).for_each(|r| {
         use_.bsset(r);
         def.bsdel(r);
       });
@@ -266,10 +266,10 @@ impl FuncGen<'_, '_> {
 }
 
 impl FuncGen<'_, '_> {
-  fn select_inst(&mut self, t: TacKind, b: &mut Vec<AsmTemplate>, arg_cnt: &mut u32) {
+  fn select_inst(&mut self, t: Tac, b: &mut Vec<AsmTemplate>, arg_cnt: &mut u32) {
     use AsmTemplate::*;
     match t {
-      TacKind::Bin { op, dst, lr } => {
+      Tac::Bin { op, dst, lr } => {
         match lr {
           [Operand::Const(l), Operand::Const(r)] => b.push(Li(vreg(dst), Imm::Int(op.eval(l, r)))),
           [Operand::Reg(l), Operand::Const(r)] => b.push(BinI(op, vreg(dst), vreg(l), Imm::Int(r))),
@@ -282,13 +282,13 @@ impl FuncGen<'_, '_> {
           [Operand::Reg(l), Operand::Reg(r)] => b.push(Bin(op, vreg(dst), vreg(l), vreg(r)))
         }
       }
-      TacKind::Un { op, dst, r } => match r[0] {
+      Tac::Un { op, dst, r } => match r[0] {
         Operand::Const(r) => b.push(Li(vreg(dst), Imm::Int(op.eval(r)))),
         // luckily(?) the name used in printing ast is just the mips asm name
         Operand::Reg(r) => b.push(Un(op, vreg(dst), vreg(r))),
       }
-      TacKind::Assign { dst, src } => self.build_mv(vreg(dst), src[0], b),
-      TacKind::Param { src } => {
+      Tac::Assign { dst, src } => self.build_mv(vreg(dst), src[0], b),
+      Tac::Param { src } => {
         let src = self.build_operand(src[0], b);
         match ARG.nth(*arg_cnt as usize) {
           Some(a) => b.push(Mv(Reg::PreColored(a), src)),
@@ -296,7 +296,7 @@ impl FuncGen<'_, '_> {
         }
         *arg_cnt += 1;
       }
-      TacKind::Call { dst, kind } => {
+      Tac::Call { dst, kind } => {
         let called = match kind {
           CallKind::Virtual(r, _) => {
             let r = self.build_operand(r[0], b);
@@ -304,31 +304,32 @@ impl FuncGen<'_, '_> {
             true
           }
           CallKind::Static(f, _) => {
-            b.push(Jal(format!("{:?}", self.program.func[f as usize].name)));
+            b.push(Jal(self.program.func[f as usize].name.clone()));
             true
           }
           CallKind::Intrinsic(i) => self.build_intrinsic(i, b),
         };
         if called {
-          // once it is really a function call, max_param should grows from 4
+          // once it is really a function call, ch_param_num should grows from 4
           // because calling convention says the first 4 argument should have their slots on the stack
-          self.max_param = self.max_param.max(*arg_cnt).max(4);
+          self.ch_param_num = self.ch_param_num.max(*arg_cnt).max(4);
         }
         *arg_cnt = 0;
         if let Some(dst) = dst { b.push(Mv(vreg(dst), mreg(V0))); }
       }
-      TacKind::Load { dst, base, off, .. } => {
+      Tac::Load { dst, base, off, .. } => {
         let base = self.build_operand(base[0], b);
         b.push(Lw(vreg(dst), base, Imm::Int(off)));
       }
-      TacKind::Store { src_base, off, .. } => {
+      Tac::Store { src_base, off, .. } => {
         let (src, base) = (self.build_operand(src_base[0], b), self.build_operand(src_base[1], b));
         b.push(Sw(src, base, Imm::Int(off)));
       }
-      TacKind::LoadInt { dst, i } => b.push(AsmTemplate::Li(vreg(dst), Imm::Int(i))),
-      TacKind::LoadStr { dst, s } => b.push(AsmTemplate::La(vreg(dst), format!("_STRING{}", s))),
-      TacKind::LoadVTbl { dst, v } => b.push(AsmTemplate::La(vreg(dst), format!("_{}", self.program.vtbl[v as usize].class))),
-      TacKind::Label { .. } | TacKind::Ret { .. } | TacKind::Jmp { .. } | TacKind::Jif { .. } => unreachable!("Shouldn't meet Ret/Jmp/Jif/Label in a tac bb."),
+      Tac::LoadInt { dst, i } => b.push(AsmTemplate::Li(vreg(dst), Imm::Int(i))),
+      Tac::LoadStr { dst, s } => b.push(AsmTemplate::La(vreg(dst), format!("_STRING{}", s))),
+      Tac::LoadVTbl { dst, v } => b.push(AsmTemplate::La(vreg(dst), format!("_{}", self.program.vtbl[v as usize].class))),
+      Tac::LoadFunc { dst, f } => b.push(AsmTemplate::La(vreg(dst), self.program.func[f as usize].name.clone())),
+      Tac::Label { .. } | Tac::Ret { .. } | Tac::Jmp { .. } | Tac::Jif { .. } => unreachable!("Shouldn't meet Ret/Jmp/Jif/Label in a tac bb."),
     }
   }
 
@@ -378,18 +379,18 @@ impl FuncGen<'_, '_> {
           self.build_mv(mreg(V0), src, b);
         }
         if idx + 2 != epilogue { // + 2, 1 for "prologue takes index 0", 1 for next bb should inc by 1 naturally
-          b.push(AsmTemplate::J(format!("{:?}_Ret", self.name)));
+          b.push(AsmTemplate::J(format!("{}_Ret", self.name)));
         }
         [Some(epilogue), None]
       }
       NextKind::Jmp(jump) => {
         if idx + 1 != jump {
-          b.push(AsmTemplate::J(format!("{:?}_L{}", self.name, jump + 1)));
+          b.push(AsmTemplate::J(format!("{}_L{}", self.name, jump + 1)));
         }
         [Some(jump + 1), None]
       }
       NextKind::Jif { cond, z, fail, jump } => {
-        b.push(AsmTemplate::B(format!("{:?}_L{}", self.name, jump + 1), vreg(cond), z));
+        b.push(AsmTemplate::B(format!("{}_L{}", self.name, jump + 1), vreg(cond), z));
         [Some(fail + 1), Some(jump + 1)]
       }
       NextKind::Halt => {
diff --git a/driver/src/lib.rs b/driver/src/lib.rs
index be86b52..6181e54 100644
--- a/driver/src/lib.rs
+++ b/driver/src/lib.rs
@@ -7,7 +7,7 @@ use syntax::{ASTAlloc, Ty, parser, parser_ll};
 use typeck::TypeCkAlloc;
 use tacopt::bb::FuncBB;
 use codegen::mips_gen::FuncGen;
-use tac::Tac;
+use tac::TacNode;
 use typed_arena::Arena;
 
 pub use test_util::*;
@@ -28,7 +28,7 @@ pub struct CompileCfg {
 pub struct Alloc<'a> {
   ast: ASTAlloc<'a>,
   typeck: TypeCkAlloc<'a>,
-  tac: Arena<Tac<'a>>,
+  tac: Arena<TacNode<'a>>,
 }
 
 // it is recommended to use this function to debug your compiler
@@ -58,12 +58,11 @@ pub fn compile<'a>(code: &'a str, alloc: &'a Alloc<'a>, cfg: CompileCfg) -> Resu
   }
   let mut new_funcs = Vec::new();
   for f in &tp.func {
-    // it is okay to unwrap because in typeck we guarantee "f's return type is not void and control flow can reaches end of function" won't happen
-    let mut fu = FuncBB::new(f).unwrap();
+    let mut fu = FuncBB::new(f);
     fu.optimizen(10);
     if cfg.stage == Stage::Asm {
       let asm = FuncGen::work(&fu, &tp, codegen::AllocMethod::Graph);
-      print::mips::func(&asm, f.name, &mut p);
+      print::mips::func(&asm, &f.name, &mut p);
     } else { // cfg.stage == Stage::TacOpt
       new_funcs.push(fu.to_tac_func());
     }
@@ -73,4 +72,4 @@ pub fn compile<'a>(code: &'a str, alloc: &'a Alloc<'a>, cfg: CompileCfg) -> Resu
     print::tac::program(&tp, &mut p);
     Ok(p.finish())
   } else { Ok(p.finish() + include_str!("../../codegen/lib.s")) }
-}
+}
\ No newline at end of file
diff --git a/print/src/mips.rs b/print/src/mips.rs
index fd6ea53..603715e 100644
--- a/print/src/mips.rs
+++ b/print/src/mips.rs
@@ -1,5 +1,5 @@
 use common::{IndentPrinter, IgnoreResult};
-use tac::{TacProgram, FuncNameKind};
+use tac::{TacProgram};
 use codegen::mips::AsmTemplate;
 use std::fmt::Write;
 
@@ -16,7 +16,7 @@ pub fn data(pr: &TacProgram, p: &mut IndentPrinter) {
       }
       write!(p, ".word _STRING{}", pr.str_pool.get_full(v.class).expect("tacgen should have put class name into `str_pool`").0).ignore();
       for &f in &v.func {
-        write!(p, ".word {:?}", pr.func[f as usize].name).ignore();
+        write!(p, ".word {}", pr.func[f as usize].name).ignore();
       }
     });
   }
@@ -29,10 +29,10 @@ pub fn data(pr: &TacProgram, p: &mut IndentPrinter) {
   writeln!(p).ignore();
 }
 
-pub fn func(f: &[AsmTemplate], name: FuncNameKind, p: &mut IndentPrinter) {
+pub fn func(f: &[AsmTemplate], name: &str, p: &mut IndentPrinter) {
   write!(p, ".text").ignore();
-  write!(p, ".globl {:?}", name).ignore();
-  write!(p, "{:?}:", name).ignore();
+  write!(p, ".globl {}", name).ignore();
+  write!(p, "{}:", name).ignore();
   p.indent(|p| for asm in f { write!(p, "{:?}", asm).ignore(); });
   writeln!(p).ignore();
-}
+}
\ No newline at end of file
diff --git a/print/src/tac.rs b/print/src/tac.rs
index 512da05..80bcd3b 100644
--- a/print/src/tac.rs
+++ b/print/src/tac.rs
@@ -1,68 +1,55 @@
-use tac::{TacProgram, TacKind, Operand, CallKind};
+use tac::{TacProgram, Tac, CallKind};
 use common::{IndentPrinter, IgnoreResult};
 use std::fmt::Write;
 
 pub fn program(pr: &TacProgram, p: &mut IndentPrinter) {
   for v in &pr.vtbl {
-    write!(p, "VTBL(_{}) {{", v.class).ignore();
+    write!(p, "VTBL<_{}> {{", v.class).ignore();
     p.indent(|p| {
       if let Some(pa) = v.parent {
         write!(p, "VTBL<_{}>", pr.vtbl[pa as usize].class).ignore();
       } else { write!(p, "0").ignore(); }
       write!(p, r#""{}""#, v.class).ignore();
       for &f in &v.func {
-        write!(p, "FUNCTION<{:?}>", pr.func[f as usize].name).ignore();
+        write!(p, "FUNC<{}>", pr.func[f as usize].name).ignore();
       }
     });
     write!(p, "}}\n\n").ignore();
   }
   for f in &pr.func {
-    write!(p, "FUNCTION({:?}) {{", f.name).ignore();
-    p.indent(|p| for t in f.iter() {
-      write_tac(&t.payload.borrow().kind, pr, p);
+    write!(p, "FUNC<{}> {{", f.name).ignore();
+    p.indent(|p| {
+      let mut iter = f.first; // manually iterate, because we don't have TacIter to use
+      while let Some(t) = iter {
+        write_tac(t.tac.get(), pr, p);
+        iter = t.next.get();
+      }
     });
     write!(p, "}}\n\n").ignore();
   }
 }
 
-pub fn write_tac(t: &TacKind, pr: &TacProgram, p: &mut IndentPrinter) {
-  use TacKind::*;
-  let opr = |o: &Operand| match o {
-    Operand::Reg(r) => format!("_T{}", r),
-    Operand::Const(c) => format!("{}", c),
-  };
+pub fn write_tac(t: Tac, pr: &TacProgram, p: &mut IndentPrinter) {
+  use Tac::*;
   match t {
-    Bin { op, dst, lr } => { write!(p, "_T{} = ({} {} {})", dst, opr(&lr[0]), op.to_op_str(), opr(&lr[1])) }
-    Un { op, dst, r } => { write!(p, "_T{} = {} {}", dst, op.to_op_str(), opr(&r[0])) }
-    Assign { dst, src } => { write!(p, "_T{} =  {}", dst, opr(&src[0])) }
-    Param { src } => { write!(p, "parm {}", opr(&src[0])) }
-    Call { dst, kind, } => {
-      write!(p, "{}call {}", dst.map(|dst| format!("_T{} = ", dst)).unwrap_or(String::new()), match kind {
-        CallKind::Virtual(fp, _) => opr(&fp[0]),
-        CallKind::Static(f, _) => format!("{:?}", pr.func[*f as usize].name),
-        CallKind::Intrinsic(i) => i.name().to_owned(),
-      })
-    }
-    Ret { src } => match src {
-      Some(src) => { write!(p, "return {}", opr(&src[0])) }
-      None => { write!(p, "return <empty>") }
-    }
-    Jmp { label } => { write!(p, "branch _L{}", label) }
-    Jif { label, z, cond } =>
-      write!(p, "if ({} {} 0) branch _L{}", opr(&cond[0]), if *z { "==" } else { "!=" }, label),
-    Label { label } => { write!(p, "_L{}:", label) }
-    Load { dst, base, off, .. } => if *off >= 0 {
-      write!(p, "_T{} = *({} + {})", dst, opr(&base[0]), off)
-    } else {
-      write!(p, "_T{} = *({} - {})", dst, opr(&base[0]), -off)
-    },
-    Store { src_base, off, .. } => if *off >= 0 {
-      write!(p, "*({} + {}) = {}", opr(&src_base[1]), off, opr(&src_base[0]))
-    } else {
-      write!(p, "*({} - {}) = {}", opr(&src_base[1]), -off, opr(&src_base[0]))
-    },
+    Bin { op, dst, lr } => write!(p, "_T{} = ({:?} {} {:?})", dst, lr[0], op.to_op_str(), lr[1]),
+    Un { op, dst, r } => write!(p, "_T{} = {} {:?}", dst, op.to_op_str(), r[0]),
+    Assign { dst, src } => write!(p, "_T{} =  {:?}", dst, src[0]),
+    Param { src } => write!(p, "parm {:?}", src[0]),
+    Call { dst, kind, } => write!(p, "{}call {}", dst.map(|dst| format!("_T{} = ", dst)).unwrap_or(String::new()), match kind {
+      CallKind::Virtual(fp, _) => format!("{:?}", fp[0]),
+      CallKind::Static(f, _) => pr.func[f as usize].name.clone(),
+      CallKind::Intrinsic(i) => i.name().to_owned(),
+    }),
+    Ret { src } => if let Some(src) = src { write!(p, "return {:?}", src[0]) } else { write!(p, "return") },
+    Jmp { label } => write!(p, "branch _L{}", label),
+    Jif { label, z, cond } => write!(p, "if ({:?} {} 0) branch _L{}", cond[0], if z { "==" } else { "!=" }, label),
+    Label { label } => write!(p, "_L{}:", label),
+    Load { dst, base, off, .. } => write!(p, "_T{} = *({:?} {} {})", dst, base[0], if off >= 0 { '+' } else { '-' }, off.abs()),
+    Store { src_base, off, .. } => write!(p, "*({:?} {} {}) = {:?}", src_base[1], if off >= 0 { '+' } else { '-' }, off.abs(), src_base[0]),
     LoadInt { dst, i } => write!(p, "_T{} = {}", dst, i),
-    LoadStr { dst, s } => write!(p, "_T{} = \"{}\"", dst, pr.str_pool.get_index(*s as usize).unwrap()),
-    LoadVTbl { dst, v } => write!(p, "_T{} = VTBL <_{}>", dst, pr.vtbl[*v as usize].class),
+    LoadStr { dst, s } => write!(p, "_T{} = \"{}\"", dst, pr.str_pool.get_index(s as usize).unwrap()),
+    LoadVTbl { dst, v } => write!(p, "_T{} = VTBL<_{}>", dst, pr.vtbl[v as usize].class),
+    LoadFunc { dst, f } => write!(p, "_T{} = FUNC<{}>", dst, pr.func[f as usize].name),
   }.ignore();
 }
\ No newline at end of file
diff --git a/tac/src/iter.rs b/tac/src/iter.rs
index de8e4cb..2030680 100644
--- a/tac/src/iter.rs
+++ b/tac/src/iter.rs
@@ -1,23 +1,23 @@
-use crate::Tac;
+use crate::TacNode;
 use std::iter::FusedIterator;
 
 // these codes are basically copied from std::collections::LinkedList
 
 #[derive(Copy, Clone)]
 pub struct TacIter<'a> {
-  first: Option<&'a Tac<'a>>,
-  last: Option<&'a Tac<'a>>,
+  first: Option<&'a TacNode<'a>>,
+  last: Option<&'a TacNode<'a>>,
   len: usize,
 }
 
 impl<'a> TacIter<'a> {
-  pub fn new(first: Option<&'a Tac<'a>>, last: Option<&'a Tac<'a>>, len: usize) -> TacIter<'a> {
+  pub fn new(first: Option<&'a TacNode<'a>>, last: Option<&'a TacNode<'a>>, len: usize) -> TacIter<'a> {
     TacIter { first, last, len }
   }
 }
 
 impl<'a> Iterator for TacIter<'a> {
-  type Item = &'a Tac<'a>;
+  type Item = &'a TacNode<'a>;
 
   fn next(&mut self) -> Option<Self::Item> {
     if self.len != 0 {
diff --git a/tac/src/lib.rs b/tac/src/lib.rs
index fb780fe..330a1a8 100644
--- a/tac/src/lib.rs
+++ b/tac/src/lib.rs
@@ -3,7 +3,7 @@ pub mod iter;
 pub use iter::TacIter;
 
 use common::{BinOp, UnOp, IndexSet};
-use std::{fmt, cell::{Cell, RefCell}};
+use std::{cell::Cell, fmt::{self, Debug}};
 use typed_arena::Arena;
 
 #[derive(Default)]
@@ -23,56 +23,44 @@ pub struct VTbl<'a> {
 
 pub struct TacFunc<'a> {
   pub param_num: u32,
-  pub max_reg: u32,
-  // check validity of this function, whether it returns without returning a value
-  pub has_ret: bool,
-  pub tac_len: u32,
-  // though normally we use first and last separately, if we write it as `first: Option<...>, last: Option<...>`
-  // we will lose the information that they can only be both Some or both None
-  pub first_last: Option<(&'a Tac<'a>, &'a Tac<'a>)>,
-  pub alloc: &'a Arena<Tac<'a>>,
-  pub name: FuncNameKind<'a>,
+  pub reg_num: u32,
+  // we don't store the number of tac here, so we can't use TacIter
+  // TacIter has more functions than we need to iterate over a function, but such functions are unnecessary
+  pub first: Option<&'a TacNode<'a>>,
+  pub last: Option<&'a TacNode<'a>>,
+  pub alloc: &'a Arena<TacNode<'a>>,
+  pub name: String,
 }
 
 impl<'a> TacFunc<'a> {
-  pub fn empty(alloc: &'a Arena<Tac<'a>>, name: FuncNameKind<'a>, param_num: u32, has_ret: bool) -> TacFunc<'a> {
-    TacFunc { param_num, max_reg: 0, has_ret, tac_len: 0, first_last: None, alloc, name }
+  pub fn empty(alloc: &'a Arena<TacNode<'a>>, name: String, param_num: u32) -> TacFunc<'a> {
+    TacFunc { param_num, reg_num: 0, first: None, last: None, alloc, name }
   }
 
-  pub fn push(&mut self, t: TacKind) -> &mut Self {
-    let tac = self.alloc.alloc(Tac { payload: TacPayload { kind: t }.into(), prev: None.into(), next: None.into() });
-    self.tac_len += 1;
-    match &mut self.first_last {
-      None => self.first_last = Some((tac, tac)),
-      Some((_, last)) => {
-        tac.prev.set(Some(last));
-        last.next.set(Some(tac));
-        *last = tac;
-      }
+  pub fn push(&mut self, t: Tac) -> &mut Self {
+    let tac = self.alloc.alloc(TacNode { tac: t.into(), prev: None.into(), next: None.into() });
+    if let Some(last) = &mut self.last {
+      tac.prev.set(Some(last));
+      last.next.set(Some(tac));
+      *last = tac;
+    } else {
+      self.first = Some(tac);
+      self.last = Some(tac);
     }
     self
   }
-
-  pub fn iter(&self) -> TacIter<'a> {
-    TacIter::new(self.first_last.map(|(f, _)| f), self.first_last.map(|(_, l)| l), self.tac_len as usize)
-  }
 }
 
-pub struct Tac<'a> {
-  pub payload: RefCell<TacPayload>,
-  pub prev: Cell<Option<&'a Tac<'a>>>,
-  pub next: Cell<Option<&'a Tac<'a>>>,
+pub struct TacNode<'a> {
+  pub tac: Cell<Tac>,
+  pub prev: Cell<Option<&'a TacNode<'a>>>,
+  pub next: Cell<Option<&'a TacNode<'a>>>,
 }
 
-// for compatibility, use a wrapper struct here instead of just using TacKind
-pub struct TacPayload {
-  pub kind: TacKind,
-}
-
-// unless specially noted, all u32 are register numbers
-// use array to help function `rw(_mut)` return a slice
+// `u32` can either mean register number or label id, its meaning is easy to distinguish according to the context
+// use array to allow function `rw(_mut)` return a slice
 #[derive(Copy, Clone)]
-pub enum TacKind {
+pub enum Tac {
   Bin { op: BinOp, dst: u32, lr: [Operand; 2] },
   Un { op: UnOp, dst: u32, r: [Operand; 1] },
   Assign { dst: u32, src: [Operand; 1] },
@@ -83,7 +71,7 @@ pub enum TacKind {
   Ret { src: Option<[Operand; 1]> },
   // label in Jmp & Je & Jne & Label
   Jmp { label: u32 },
-  // Jif stands for Jz and Jnz, determined by z
+  // Jif stands for Jz and Jnz, determined by `z`
   Jif { label: u32, z: bool, cond: [Operand; 1] },
   Label { label: u32 },
   // `hint` can help common expression elimination since we don't have alias analysis yet
@@ -96,12 +84,14 @@ pub enum TacKind {
   LoadStr { dst: u32, s: u32 },
   // v: the index in TacProgram::vtbl
   LoadVTbl { dst: u32, v: u32 },
+  // v: the index in TacProgram::func
+  LoadFunc { dst: u32, f: u32 },
 }
 
-impl TacKind {
+impl Tac {
   // r can be Operand, but w can only be reg, and there is at most 1 w
   pub fn rw(&self) -> (&[Operand], Option<u32>) {
-    use TacKind::*;
+    use Tac::*;
     match self {
       Bin { dst, lr, .. } => (lr, Some(*dst)),
       Un { dst, r, .. } | Assign { dst, src: r } | Load { dst, base: r, .. } => (r, Some(*dst)),
@@ -111,14 +101,14 @@ impl TacKind {
       Jmp { .. } | Label { .. } => (&[], None),
       Jif { cond, .. } => (cond, None),
       Store { src_base, .. } => (src_base, None),
-      LoadInt { dst, .. } | LoadStr { dst, .. } | LoadVTbl { dst, .. } => (&[], Some(*dst)),
+      LoadInt { dst, .. } | LoadStr { dst, .. } | LoadVTbl { dst, .. } | LoadFunc { dst, .. } => (&[], Some(*dst)),
     }
   }
 
   // basically copied from `rw`, there is no better way in rust to write two functions, one is &self -> &result, another is &mut self -> &mut result
   // for example, the implementation of Iter and IterMut in many std collections are almost duplicate codes
   pub fn rw_mut(&mut self) -> (&mut [Operand], Option<&mut u32>) {
-    use TacKind::*;
+    use Tac::*;
     match self {
       Bin { dst, lr, .. } => (lr, Some(dst)),
       Un { dst, r, .. } | Assign { dst, src: r } | Load { dst, base: r, .. } => (r, Some(dst)),
@@ -129,7 +119,7 @@ impl TacKind {
       Jmp { .. } | Label { .. } => (&mut [], None),
       Jif { cond, .. } => (cond, None),
       Store { src_base, .. } => (src_base, None),
-      LoadInt { dst, .. } | LoadStr { dst, .. } | LoadVTbl { dst, .. } => (&mut [], Some(dst)),
+      LoadInt { dst, .. } | LoadStr { dst, .. } | LoadVTbl { dst, .. } | LoadFunc { dst, .. } => (&mut [], Some(dst)),
     }
   }
 }
@@ -145,6 +135,12 @@ pub enum CallKind {
 #[derive(Copy, Clone, Hash, Eq, PartialEq)]
 pub enum Operand { Reg(u32), Const(i32) }
 
+impl Debug for Operand {
+  fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+    match self { Operand::Reg(r) => write!(f, "_T{}", r), Operand::Const(c) => write!(f, "{}", c) }
+  }
+}
+
 #[derive(Copy, Clone, Eq, PartialEq, Debug, strum_macros::IntoStaticStr)]
 pub enum Intrinsic { _Alloc, _ReadLine, _ReadInt, _StringEqual, _PrintInt, _PrintString, _PrintBool, _Halt }
 
@@ -153,26 +149,7 @@ impl Intrinsic {
 
   pub fn has_ret(self) -> bool {
     use Intrinsic::*;
-    match self {
-      _Alloc | _ReadLine | _ReadInt | _StringEqual => true, _PrintInt | _PrintString | _PrintBool | _Halt => false
-    }
-  }
-}
-
-#[derive(Copy, Clone)]
-pub enum FuncNameKind<'a> {
-  Main,
-  New { class: &'a str },
-  Member { class: &'a str, func: &'a str },
-}
-
-impl fmt::Debug for FuncNameKind<'_> {
-  fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
-    match self {
-      FuncNameKind::Main => write!(f, "main"),
-      FuncNameKind::New { class } => write!(f, "_{}_New", class),
-      FuncNameKind::Member { class, func } => write!(f, "_{}.{}", class, func),
-    }
+    match self { _Alloc | _ReadLine | _ReadInt | _StringEqual => true, _PrintInt | _PrintString | _PrintBool | _Halt => false }
   }
 }
 
diff --git a/tacgen/src/lib.rs b/tacgen/src/lib.rs
index 9851609..d6ca9a0 100644
--- a/tacgen/src/lib.rs
+++ b/tacgen/src/lib.rs
@@ -1,31 +1,32 @@
 mod info;
 
 use syntax::{ast::*, ty::*, ScopeOwner};
-use ::tac::{*, self, TacKind, TacKind::*, Operand::*, Intrinsic::*};
+use ::tac::{self, *, Tac::{self, *}, Operand::*, Intrinsic::*};
 use common::{Ref, MAIN_METHOD, BinOp::*, UnOp::*, IndexSet, IndexMap, HashMap};
 use typed_arena::Arena;
 use crate::info::*;
 
 #[derive(Default)]
 struct TacGen<'a> {
-  reg_cnt: u32,
+  reg_num: u32,
   label_cnt: u32,
   loop_stk: Vec<u32>,
   // Id & Index will behave differently when they are the lhs of an assignment
   // cur_assign contains the current assign rhs operand, or None if the current handling expr doesn't involve in assign
   cur_assign: Option<Operand>,
   str_pool: IndexSet<&'a str>,
+  // `*_info` just works like extra fields to those structs, their specific meaning can be found at `struct *Info`
   var_info: HashMap<Ref<'a, VarDef<'a>>, VarInfo>,
   func_info: HashMap<Ref<'a, FuncDef<'a>>, FuncInfo>,
   class_info: HashMap<Ref<'a, ClassDef<'a>>, ClassInfo<'a>>,
 }
 
-pub fn work<'a>(p: &'a Program<'a>, alloc: &'a Arena<Tac<'a>>) -> TacProgram<'a> {
+pub fn work<'a>(p: &'a Program<'a>, alloc: &'a Arena<TacNode<'a>>) -> TacProgram<'a> {
   TacGen::default().program(p, alloc)
 }
 
 impl<'a> TacGen<'a> {
-  fn program(mut self, p: &Program<'a>, alloc: &'a Arena<Tac<'a>>) -> TacProgram<'a> {
+  fn program(mut self, p: &Program<'a>, alloc: &'a Arena<TacNode<'a>>) -> TacProgram<'a> {
     let mut tp = TacProgram::default();
     for (idx, &c) in p.class.iter().enumerate() {
       self.define_str(c.name);
@@ -34,7 +35,7 @@ impl<'a> TacGen<'a> {
       tp.func.push(self.build_new(c, alloc));
     }
     {
-      let mut idx = tp.func.len() as u32; // their are already some `_Xxx_New` functions in tp.func
+      let mut idx = tp.func.len() as u32; // their are already some `_Xxx._new` functions in tp.func, so can't start from 0
       for &c in &p.class {
         for &f in &c.field {
           if let FieldDef::FuncDef(f) = f {
@@ -52,19 +53,14 @@ impl<'a> TacGen<'a> {
             self.var_info.insert(Ref(p), VarInfo { off: idx as u32 + this });
           }
           // these regs are occupied by parameters
-          self.reg_cnt = fu.param.len() as u32 + this;
+          self.reg_num = fu.param.len() as u32 + this;
           self.label_cnt = 0;
-          let mut f = TacFunc::empty(alloc, if Ref(c) == Ref(p.main.get().unwrap()) && fu.name == MAIN_METHOD {
-            FuncNameKind::Main
-          } else {
-            FuncNameKind::Member { class: c.name, func: fu.name }
-          }, self.reg_cnt, fu.ret_ty() != Ty::void());
+          let name = if Ref(c) == Ref(p.main.get().unwrap()) && fu.name == MAIN_METHOD { MAIN_METHOD.into() } else { format!("_{}.{}", c.name, fu.name) };
+          let mut f = TacFunc::empty(alloc, name, self.reg_num);
           self.block(&fu.body, &mut f);
-          f.max_reg = self.reg_cnt;
+          f.reg_num = self.reg_num;
           // add an return at the end of return-void function
-          if fu.ret_ty() == Ty::void() {
-            f.push(TacKind::Ret { src: None });
-          }
+          if fu.ret_ty() == Ty::void() { f.push(Tac::Ret { src: None }); }
           tp.func.push(f);
         }
       }
@@ -95,7 +91,7 @@ impl<'a> TacGen<'a> {
         let reg = self.reg();
         self.var_info.insert(Ref(v), VarInfo { off: reg });
         let init = v.init.as_ref().map(|(_, e)| self.expr(e, f)).unwrap_or(Const(0));
-        f.push(TacKind::Assign { dst: reg, src: [init] });
+        f.push(Tac::Assign { dst: reg, src: [init] });
       }
       ExprEval(e) => { self.expr(e, f); }
       Skip(_) => {}
@@ -156,11 +152,9 @@ impl<'a> TacGen<'a> {
         f.push(Label { label: after_body });
         self.loop_stk.pop();
       }
-      Return(r) => if let Some(e) = r {
-        let ret = self.expr(e, f);
-        f.push(Ret { src: Some([ret]) });
-      } else {
-        f.push(Ret { src: None });
+      Return(r) => {
+        let src = r.as_ref().map(|e| [self.expr(e, f)]);
+        f.push(Ret { src });
       }
       Print(p) => for e in p {
         let reg = self.expr(e, f);
@@ -181,52 +175,55 @@ impl<'a> TacGen<'a> {
     use ExprKind::*;
     let assign = self.cur_assign.take();
     match &e.kind {
-      VarSel(v) => Reg({
+      VarSel(v) => {
         let var = v.var.get().unwrap();
-        let off = self.var_info[&Ref(var)].off;
+        let off = self.var_info[&Ref(var)].off; // may be register id or offset in class
         match var.owner.get().unwrap() {
-          ScopeOwner::Local(_) | ScopeOwner::Param(_) => if let Some(src) = assign { // off is register
-            // don't care this return, the below 0 is the same
-            (f.push(TacKind::Assign { dst: off, src: [src] }), 0).1
-          } else { off }
-          ScopeOwner::Class(_) => { // off is offset
+          ScopeOwner::Local(_) | ScopeOwner::Param(_) => if let Some(src) = assign { // `off` is register
+            f.push(Tac::Assign { dst: off, src: [src] });
+            // the return value won't be used, so just return a meaningless Reg(0), the below Reg(0)s are the same
+            Reg(0)
+          } else { Reg(off) }
+          ScopeOwner::Class(_) => { // `off` is offset
             // `this` is at argument 0
             let owner = v.owner.as_ref().map(|o| self.expr(o, f)).unwrap_or(Reg(0));
-            match assign {
-              Some(src) => (f.push(Store { src_base: [src, owner], off: off as i32 * INT_SIZE, hint: MemHint::Obj }), 0).1,
-              None => {
-                let dst = self.reg();
-                (f.push(Load { dst, base: [owner], off: off as i32 * INT_SIZE, hint: MemHint::Obj }), dst).1
-              }
+            if let Some(src) = assign {
+              f.push(Store { src_base: [src, owner], off: off as i32 * INT_SIZE, hint: MemHint::Obj });
+              Reg(0)
+            } else {
+              let dst = self.reg();
+              f.push(Load { dst, base: [owner], off: off as i32 * INT_SIZE, hint: MemHint::Obj });
+              Reg(dst)
             }
           }
           ScopeOwner::Global(_) => unreachable!("Impossible to declare a variable in global scope."),
         }
-      }),
-      IndexSel(i) => Reg({
+      }
+      IndexSel(i) => {
         let (arr, idx) = (self.expr(&i.arr, f), self.expr(&i.idx, f));
         let (ok, len, cmp) = (self.reg(), self.length(arr, f), self.reg());
         let (err, after) = (self.label(), self.label());
         f.push(Bin { op: Ge, dst: ok, lr: [idx, Const(0)] })
-          .push(Bin { op: Lt, dst: cmp, lr: [idx, Reg(len)] })
+          .push(Bin { op: Lt, dst: cmp, lr: [idx, len] })
           .push(Bin { op: And, dst: ok, lr: [Reg(ok), Reg(cmp)] })
           .push(Jif { label: err, z: true, cond: [Reg(ok)] });
         // range check passed if reach here
         let off = self.reg();
         f.push(Bin { op: Mul, dst: off, lr: [idx, Const(INT_SIZE)] })
           .push(Bin { op: Add, dst: off, lr: [Reg(off), arr] });
-        let ret = match assign {
-          Some(src) => (f.push(Store { src_base: [src, Reg(off)], off: 0, hint: MemHint::Arr }), 0).1,
-          None => {
-            let reg = self.reg();
-            (f.push(Load { dst: reg, base: [Reg(off)], off: 0, hint: MemHint::Arr }), reg).1
-          }
+        let ret = if let Some(src) = assign {
+          f.push(Store { src_base: [src, Reg(off)], off: 0, hint: MemHint::Arr });
+          Reg(0)
+        } else {
+          let dst = self.reg();
+          f.push(Load { dst, base: [Reg(off)], off: 0, hint: MemHint::Arr });
+          Reg(dst)
         };
         f.push(Jmp { label: after });
         self.re(INDEX_OUT_OF_BOUND, f.push(Label { label: err }));
         f.push(Label { label: after });
         ret
-      }),
+      }
       IntLit(i) => Const(*i),
       BoolLit(b) => Const(*b as i32),
       StringLit(s) => {
@@ -237,7 +234,7 @@ impl<'a> TacGen<'a> {
       NullLit(_) => Const(0),
       Call(c) => {
         let v = if let ExprKind::VarSel(v) = &c.func.kind { v } else { unimplemented!() };
-        Reg(match &v.owner {
+        match &v.owner {
           Some(o) if o.ty.get().is_arr() => {
             let arr = self.expr(o, f);
             self.length(arr, f)
@@ -251,30 +248,27 @@ impl<'a> TacGen<'a> {
               arg_arr: c.arg.iter().any(|a| a.ty.get().arr > 0),
             };
             if fu.static_ {
-              for a in args {
-                f.push(Param { src: [a] });
-              }
-              f.push(TacKind::Call { dst: ret, kind: CallKind::Static(self.func_info[&Ref(fu)].idx, hint) });
+              for a in args { f.push(Param { src: [a] }); }
+              f.push(Tac::Call { dst: ret, kind: CallKind::Static(self.func_info[&Ref(fu)].idx, hint) });
             } else {
               // Reg(0) is `this`
               let owner = v.owner.as_ref().map(|o| self.expr(o, f)).unwrap_or(Reg(0));
               f.push(Param { src: [owner] });
-              for a in args {
-                f.push(Param { src: [a] });
-              }
+              for a in args { f.push(Param { src: [a] }); }
               let slot = self.reg();
               let off = self.func_info[&Ref(fu)].off;
               f.push(Load { dst: slot, base: [owner], off: 0, hint: MemHint::Immutable })
                 .push(Load { dst: slot, base: [Reg(slot)], off: off as i32 * INT_SIZE, hint: MemHint::Immutable });
-              f.push(TacKind::Call { dst: ret, kind: CallKind::Virtual([Reg(slot)], hint) });
+              f.push(Tac::Call { dst: ret, kind: CallKind::Virtual([Reg(slot)], hint) });
             }
-            ret.unwrap_or(0) // if ret is None, the result can't be assigned to others, so 0 will not be used
+            Reg(ret.unwrap_or(0)) // if ret is None, the result can't be assigned to others, so 0 will not be used
           }
-        })
+        }
       }
       Unary(u) => {
         let (r, dst) = (self.expr(&u.r, f), self.reg());
-        (f.push(Un { op: u.op, dst, r: [r] }), Reg(dst)).1
+        f.push(Un { op: u.op, dst, r: [r] });
+        Reg(dst)
       }
       Binary(b) => {
         let (l, r) = (self.expr(&b.l, f), self.expr(&b.r, f));
@@ -289,20 +283,21 @@ impl<'a> TacGen<'a> {
           }
           op => {
             let dst = self.reg();
-            (f.push(Bin { op, dst, lr: [l, r] }), Reg(dst)).1
+            f.push(Bin { op, dst, lr: [l, r] });
+            Reg(dst)
           }
         }
       }
       This(_) => Reg(0),
       ReadInt(_) => Reg(self.intrinsic(_ReadInt, f).unwrap()),
       ReadLine(_) => Reg(self.intrinsic(_ReadLine, f).unwrap()),
-      NewClass(n) => Reg({
+      NewClass(n) => {
         let dst = self.reg();
         // by design, a class's new func in functions have the same index as its vtbl in vtbls
-        f.push(TacKind::Call { dst: Some(dst), kind: CallKind::Static(self.class_info[&Ref(n.class.get().unwrap())].idx, CallHint { arg_obj: false, arg_arr: false }) });
-        dst
-      }),
-      NewArray(n) => Reg({
+        f.push(Tac::Call { dst: Some(dst), kind: CallKind::Static(self.class_info[&Ref(n.class.get().unwrap())].idx, CallHint { arg_obj: false, arg_arr: false }) });
+        Reg(dst)
+      }
+      NewArray(n) => {
         let len = self.expr(&n.len, f);
         let (ok, before_cond, before_body) = (self.label(), self.label(), self.label());
         let (cmp, ptr) = (self.reg(), self.reg());
@@ -324,17 +319,17 @@ impl<'a> TacGen<'a> {
           .push(Bin { op: Eq, dst: cmp, lr: [Reg(ptr), Reg(arr)] })
           .push(Jif { label: before_body, z: true, cond: [Reg(cmp)] }); // when ptr == arr, loop end
         f.push(Store { src_base: [len, Reg(arr)], off: -INT_SIZE, hint: MemHint::Immutable }); // arr[-1] = len
-        arr
-      }),
-      ClassTest(t) => Reg({
+        Reg(arr)
+      }
+      ClassTest(t) => {
         let obj = self.expr(&t.expr, f);
         self.check_cast(obj, self.class_info[&Ref(t.class.get().unwrap())].idx, f)
-      }),
+      }
       ClassCast(t) => {
         let obj = self.expr(&t.expr, f);
         let check = self.check_cast(obj, self.class_info[&Ref(t.class.get().unwrap())].idx, f);
         let (msg, vtbl, ok) = (self.reg(), self.reg(), self.label());
-        f.push(Jif { label: ok, z: false, cond: [Reg(check)] });
+        f.push(Jif { label: ok, z: false, cond: [check] });
         let s = self.define_str(BAD_CAST1); // borrow checker...
         self.intrinsic(_PrintString, f.push(LoadStr { dst: msg, s }).push(Param { src: [Reg(msg)] }));
         self.intrinsic(_PrintString, f.push(Load { dst: vtbl, base: [obj], off: 0, hint: MemHint::Immutable })
@@ -354,9 +349,10 @@ impl<'a> TacGen<'a> {
 }
 
 impl<'a> TacGen<'a> {
+  // define a string in str pool and return its id, this id can be used in Tac::LoadStr
   fn define_str(&mut self, s: &'a str) -> u32 { self.str_pool.insert_full(s).0 as u32 }
 
-  fn reg(&mut self) -> u32 { (self.reg_cnt, self.reg_cnt += 1).0 }
+  fn reg(&mut self) -> u32 { (self.reg_num, self.reg_num += 1).0 }
 
   fn label(&mut self) -> u32 { (self.label_cnt, self.label_cnt += 1).0 }
 
@@ -367,19 +363,21 @@ impl<'a> TacGen<'a> {
     ret
   }
 
+  // perform an intrinsic call, return value is Some if this intrinsic call has return value
   fn intrinsic(&mut self, i: Intrinsic, f: &mut TacFunc<'a>) -> Option<u32> {
     let ret = if i.has_ret() { Some(self.reg()) } else { None };
-    f.push(TacKind::Call { dst: ret, kind: CallKind::Intrinsic(i) });
+    f.push(Tac::Call { dst: ret, kind: CallKind::Intrinsic(i) });
     ret
   }
 
-  fn length(&mut self, arr: Operand, f: &mut TacFunc<'a>) -> u32 {
+  // read the length of `arr` (caller should guarantee `arr` is really an array)
+  fn length(&mut self, arr: Operand, f: &mut TacFunc<'a>) -> Operand {
     let ret = self.reg();
     f.push(Load { dst: ret, base: [arr], off: -(INT_SIZE as i32), hint: MemHint::Immutable });
-    ret
+    Reg(ret)
   }
 
-  // re for runtime error
+  // re is short for for runtime error; this function prints a message and call halt
   fn re(&mut self, msg: &'static str, f: &mut TacFunc<'a>) {
     let src = self.reg();
     let s = self.define_str(msg);
@@ -387,7 +385,7 @@ impl<'a> TacGen<'a> {
     self.intrinsic(_Halt, f);
   }
 
-  fn check_cast(&mut self, obj: Operand, vtbl_idx: u32, f: &mut TacFunc<'a>) -> u32 {
+  fn check_cast(&mut self, obj: Operand, vtbl_idx: u32, f: &mut TacFunc<'a>) -> Operand {
     // ret = 0
     // while (cur)
     //   ret = (cur == target)
@@ -404,29 +402,26 @@ impl<'a> TacGen<'a> {
     f.push(Load { dst: cur, base: [Reg(cur)], off: 0, hint: MemHint::Immutable });
     f.push(Jmp { label: before_cond });
     f.push(Label { label: after_body });
-    ret
+    Reg(ret)
   }
 }
 
 impl<'a> TacGen<'a> {
-  // `idx` in ClassInfo & FuncInfo is not determined here, just use 0
-  // it is guaranteed that all functions (static/virtual) are inserted into self.func_info
-  // this function depends on the fact that no cyclic inheritance exist, which is guaranteed in typeck
+  // `idx` in ClassInfo & FuncInfo is not determined here, just set them to a meaningless value (0)
+  // all functions (static & virtual) are inserted into self.func_info
+  // this function relies on the fact that no cyclic inheritance exist, which is guaranteed in typeck
   fn resolve_field(&mut self, c: &'a ClassDef<'a>) {
     if !self.class_info.contains_key(&Ref(c)) {
       let (mut field_cnt, mut vtbl) = if let Some(p) = c.parent_ref.get() {
         self.resolve_field(p);
         let p = &self.class_info[&Ref(p)];
         (p.field_cnt, p.vtbl.clone())
-      } else {
-        // starting from 1, partly because of vtbl is at 0, mainly because > 0 can be used to determine whether already resolved
-        (1, IndexMap::default())
-      };
+      } else { (1, IndexMap::default()) };
       for f in &c.field {
         match f {
           FieldDef::FuncDef(f) => if !f.static_ {
             if let Some((idx, _, p_f)) = vtbl.get_full_mut(f.name) {
-              // + 2 for 0 is parent vtbl, 1 is class name
+              // + 2, because 0 is parent vtbl, 1 is class name
               self.func_info.insert(Ref(f), FuncInfo { off: idx as u32 + 2, idx: 0 });
               *p_f = f; // override
             } else {
@@ -434,7 +429,7 @@ impl<'a> TacGen<'a> {
               vtbl.insert(f.name, f);
             }
           } else {
-            // off is useless for static functions
+            // `off` is useless for static functions
             self.func_info.insert(Ref(f), FuncInfo { off: 0, idx: 0 });
           }
           FieldDef::VarDef(v) => {
@@ -447,10 +442,10 @@ impl<'a> TacGen<'a> {
     }
   }
 
-  fn build_new(&mut self, c: &'a ClassDef<'a>, alloc: &'a Arena<Tac<'a>>) -> TacFunc<'a> {
-    self.reg_cnt = 0;
+  fn build_new(&mut self, c: &'a ClassDef<'a>, alloc: &'a Arena<TacNode<'a>>) -> TacFunc<'a> {
+    self.reg_num = 0;
     let ClassInfo { field_cnt, idx, .. } = self.class_info[&Ref(c)];
-    let mut f = TacFunc::empty(alloc, FuncNameKind::New { class: c.name }, 0, true);
+    let mut f = TacFunc::empty(alloc, format!("_{}._new", c.name), 0);
     f.push(Param { src: [Const(field_cnt as i32 * INT_SIZE)] });
     let ret = self.intrinsic(_Alloc, &mut f).unwrap();
     let vtbl = self.reg();
@@ -460,7 +455,7 @@ impl<'a> TacGen<'a> {
       f.push(Store { src_base: [Const(0), Reg(ret)], off: i as i32 * INT_SIZE, hint: MemHint::Obj });
     }
     f.push(Ret { src: Some([Reg(ret)]) });
-    f.max_reg = self.reg_cnt;
+    f.reg_num = self.reg_num;
     f
   }
-}
+}
\ No newline at end of file
diff --git a/tacopt/src/bb.rs b/tacopt/src/bb.rs
index 1ad9032..84c343a 100644
--- a/tacopt/src/bb.rs
+++ b/tacopt/src/bb.rs
@@ -1,4 +1,4 @@
-use tac::{Tac, TacKind, TacFunc, Operand, FuncNameKind, TacIter, CallKind, Intrinsic::_Halt};
+use tac::{TacNode, Tac, TacFunc, Operand, TacIter, CallKind, Intrinsic::_Halt};
 use common::Ref;
 use typed_arena::Arena;
 
@@ -6,8 +6,8 @@ pub struct BB<'a> {
   pub len: u32,
   // the ret/jmp/jif/label is NOT contained in the link list defined by first -> last
   // don't forget ret/jif may contain a register in data flow analysis
-  pub first: Option<&'a Tac<'a>>,
-  pub last: Option<&'a Tac<'a>>,
+  pub first: Option<&'a TacNode<'a>>,
+  pub last: Option<&'a TacNode<'a>>,
   pub next: NextKind,
   pub prev: Vec<u32>,
 }
@@ -54,7 +54,7 @@ impl<'a> BB<'a> {
   }
 
   // the link on t is not cut down, so you can safely del a tac while iterating over it
-  pub fn del(&mut self, t: &'a Tac<'a>) {
+  pub fn del(&mut self, t: &'a TacNode<'a>) {
     self.len -= 1;
     match self.first {
       Some(first) if Ref(first) == Ref(t) => {
@@ -75,7 +75,7 @@ impl<'a> BB<'a> {
     }
   }
 
-  pub fn insert_after(&mut self, loc: &'a Tac<'a>, new: &'a Tac<'a>) {
+  pub fn insert_after(&mut self, loc: &'a TacNode<'a>, new: &'a TacNode<'a>) {
     self.len += 1;
     match self.last {
       Some(last) if Ref(last) == Ref(loc) => {
@@ -102,37 +102,33 @@ impl<'a> BB<'a> {
 }
 
 pub struct FuncBB<'a> {
-  // some fields copied from TacFunc, but they may change during optimization, so I decide not to borrow TacFunc
+  // some fields copied from TacFunc, they may change during optimization, so do copy rather than borrow
   pub param_num: u32,
-  // max_reg and max_tac are actually the max id of reg/tac + 1, so if you need to allocate array for them, no need to + 1
-  // during optimization, if they decrease, don't need to update FuncBB, but if they increase, do remember to update
-  pub max_reg: u32,
-  pub max_tac: u32,
-  pub has_ret: bool,
-  pub alloc: &'a Arena<Tac<'a>>,
+  pub reg_num: u32,
+  pub alloc: &'a Arena<TacNode<'a>>,
   pub bb: Vec<BB<'a>>,
-  pub name: FuncNameKind<'a>,
+  // I admit it is a design fault, we need to clone func's name here for convenience, otherwise we may need to modify a lot of code
+  // nevertheless, the affect on performance is very little
+  pub name: String,
 }
 
 impl<'a> FuncBB<'a> {
-  // will add a new inst(ret) to f, but will not inc f.tac_len; it is okay because future work is based on bb but not f, f.tac_len is no longer used
-  // return None if f's return type is not void and control flow can reaches end of function
-  pub fn new<'b>(f: &'b TacFunc<'a>) -> Option<FuncBB<'a>> {
+  // `f` should returns on every execution, otherwise `simplify` will panic
+  pub fn new(f: &TacFunc<'a>) -> FuncBB<'a> {
     let mut bb = Vec::new();
-    let mut label2bb = Vec::new();
-    let mut label_to_map = Vec::new();
-    let mut iter = f.first_last.map(|(f, _)| f);
+    let mut label2bb = Vec::new(); // label2bb[label id] = bb id of this label
+    let mut labels = Vec::new(); // labels = {bb id | bb.next contains label id}
+    let mut iter = f.first;
     while let Some(first) = iter {
+      // is_next: 0 for this label belongs to this bb, 1 for this label belongs to the next bb
       let mut mark_label = |label: u32, is_next: u32| {
         let label = label as usize;
-        if label2bb.len() <= label {
-          label2bb.resize(label + 1, 0);
-        }
+        if label2bb.len() <= label { label2bb.resize(label + 1, 0); }
         label2bb[label] = bb.len() as u32 + is_next;
       };
       let mut first = Some(first);
       while let Some(t) = first {
-        if let TacKind::Label { label } = t.payload.borrow().kind {
+        if let Tac::Label { label } = t.tac.get() {
           mark_label(label, 0);
           first = t.next.get();
         } else { break; }
@@ -143,56 +139,53 @@ impl<'a> FuncBB<'a> {
       // label index should be remapped to bb index that the label belongs to
       let mut has_label = false;
       let next = loop {
-        match cur {
-          None => break NextKind::Ret(None),
-          Some(cur1) => {
-            match cur1.payload.borrow().kind {
-              TacKind::Label { label } => {
-                mark_label(label, 1);
-                break NextKind::Jmp(bb.len() as u32 + 1);
-              }
-              TacKind::Jmp { label } => {
+        if let Some(cur1) = cur {
+          match cur1.tac.get() {
+            Tac::Label { label } => {
+              mark_label(label, 1);
+              break NextKind::Jmp(bb.len() as u32 + 1);
+            }
+            Tac::Jmp { label } => {
+              has_label = true;
+              break NextKind::Jmp(label);
+            }
+            Tac::Jif { label, z, cond } => break match cond[0] {
+              Operand::Const(c) => if (c == 0) == z { // (Jz, and is z) or (Jnz and is not z), do the jump
                 has_label = true;
-                break NextKind::Jmp(label);
-              }
-              TacKind::Jif { label, z, cond } => break match cond[0] {
-                Operand::Const(c) => if (c == 0) == z { // (Jz, and is z) or (Jnz and is not z), do the jump
-                  has_label = true;
-                  NextKind::Jmp(label)
-                } else { NextKind::Jmp(bb.len() as u32 + 1) }
-                Operand::Reg(r) => {
-                  has_label = true;
-                  NextKind::Jif { cond: r, z, fail: bb.len() as u32 + 1, jump: label }
-                }
-              },
-              TacKind::Ret { src } => break NextKind::Ret(src.map(|src| src[0])),
-              TacKind::Call { kind: CallKind::Intrinsic(_Halt), .. } => break NextKind::Halt,
-              _ => {
-                if first.is_none() { first = cur; }
-                last = cur;
-                len += 1;
+                NextKind::Jmp(label)
+              } else { NextKind::Jmp(bb.len() as u32 + 1) }
+              Operand::Reg(r) => {
+                has_label = true;
+                NextKind::Jif { cond: r, z, fail: bb.len() as u32 + 1, jump: label }
               }
+            },
+            Tac::Ret { src } => break NextKind::Ret(src.map(|src| src[0])),
+            Tac::Call { kind: CallKind::Intrinsic(_Halt), .. } => break NextKind::Halt,
+            _ => {
+              if first.is_none() { first = cur; }
+              last = cur;
+              len += 1;
             }
-            cur = cur1.next.get();
           }
+          cur = cur1.next.get();
+        } else {
+          // reaching here means the last tac is not `return`, but we still don't add `return` here, instead we add `jmp`
+          // in this way, if the last bb is reachable, it will be certain to cause panicking in `simplify`
+          break NextKind::Jmp(bb.len() as u32 + 1);
         }
       };
       iter = cur.and_then(|cur| cur.next.get());
-      if has_label { label_to_map.push(bb.len() as u32); }
+      if has_label { labels.push(bb.len() as u32); }
       if let Some(first) = first { first.prev.set(None); }
       if let Some(last) = last { last.next.set(None); }
       bb.push(BB { len, first, last, next, prev: vec![] });
     }
-    bb.push(BB { len: 0, first: None, last: None, next: NextKind::Ret(None), prev: vec![] });
-    for unfill in label_to_map {
+    for unfill in labels {
       match &mut bb[unfill as usize].next {
         NextKind::Jmp(jump) | NextKind::Jif { jump, .. } => *jump = label2bb[*jump as usize], _ => {}
       }
     }
-    checked_simplify(bb, Some(f)).map(|bb| {
-      let (max_reg, max_tac) = (f.max_reg, f.tac_len);
-      FuncBB { param_num: f.param_num, max_reg, max_tac, has_ret: f.has_ret, alloc: f.alloc, bb, name: f.name }
-    })
+    FuncBB { param_num: f.param_num, reg_num: f.reg_num, alloc: f.alloc, bb: simplify(bb), name: f.name.clone() }
   }
 
   pub fn optimize(&mut self) {
@@ -207,56 +200,40 @@ impl<'a> FuncBB<'a> {
   }
 
   pub fn new_reg(&mut self) -> u32 {
-    (self.max_reg, self.max_reg += 1).0
-  }
-
-  pub fn new_tac(&mut self) -> u32 {
-    (self.max_tac, self.max_tac += 1).0
+    (self.reg_num, self.reg_num += 1).0
   }
 
   pub fn to_tac_func(&self) -> TacFunc<'a> {
-    let mut f = TacFunc::empty(self.alloc, self.name, self.param_num, self.has_ret);
-    f.max_reg = self.max_reg;
+    let mut f = TacFunc::empty(self.alloc, self.name.clone(), self.param_num);
+    f.reg_num = self.reg_num;
     for (idx, b) in self.bb.iter().enumerate() {
       // generate label and jump only when necessary
       if !(b.prev.is_empty() || (b.prev.len() == 1 && b.prev[0] + 1 == idx as u32)) {
-        f.push(TacKind::Label { label: idx as u32 });
-      }
-      for t in b.iter() {
-        f.push(t.payload.borrow().kind); // shouldn't have ret/... here
+        f.push(Tac::Label { label: idx as u32 });
       }
+      // shouldn't have ret/... here
+      for t in b.iter() { f.push(t.tac.get()); }
       match b.next {
-        NextKind::Ret(src) => { f.push(TacKind::Ret { src: src.map(|src| [src]) }); }
-        NextKind::Jmp(jump) => if jump != idx as u32 + 1 { f.push(TacKind::Jmp { label: jump }); }
-        NextKind::Jif { cond, z, jump, .. } => { f.push(TacKind::Jif { label: jump, z, cond: [Operand::Reg(cond)] }); }
-        NextKind::Halt => { f.push(TacKind::Call { dst: None, kind: CallKind::Intrinsic(_Halt) }); }
+        NextKind::Ret(src) => { f.push(Tac::Ret { src: src.map(|src| [src]) }); }
+        NextKind::Jmp(jump) => if jump != idx as u32 + 1 { f.push(Tac::Jmp { label: jump }); }
+        NextKind::Jif { cond, z, jump, .. } => { f.push(Tac::Jif { label: jump, z, cond: [Operand::Reg(cond)] }); }
+        NextKind::Halt => { f.push(Tac::Call { dst: None, kind: CallKind::Intrinsic(_Halt) }); }
       };
     }
     f
   }
 }
 
-// remove unreachable bb(next and prev is properly rewritten)
-// return None for error, i.e, if this function returns without returning a value and f.has_ret == true
-// if f is None, no check is performed, must return Some
-pub(crate) fn checked_simplify<'a>(mut bb: Vec<BB<'a>>, f: Option<&TacFunc>) -> Option<Vec<BB<'a>>> {
+// possible to trigger `index out of bounds` here (if constraint is violated), see the comment in `FuncBB::new`
+pub(crate) fn simplify(mut bb: Vec<BB>) -> Vec<BB> {
   fn dfs(x: usize, bb: &mut [BB], vis: &mut [bool]) {
     if vis[x] { return; }
     vis[x] = true;
     bb[x].next().iter().filter_map(|&x| x).for_each(|x| dfs(x as usize, bb, vis));
   }
-
   let mut vis = vec![false; bb.len()];
   dfs(0, &mut bb, &mut vis);
-  if f.map(|f| f.has_ret).unwrap_or(false) {
-    for (idx, b) in bb.iter().enumerate() {
-      if vis[idx] && match b.next { NextKind::Ret(None) => true, _ => false, } {
-        return None;
-      }
-    }
-  }
-
-  let mut actual = vec![0; bb.len()];
+  let mut actual = vec![0; bb.len()]; // exclusive prefix sum of `vis`
   for i in 1..bb.len() {
     actual[i] += actual[i - 1] + vis[i - 1] as u32;
   }
@@ -271,10 +248,8 @@ pub(crate) fn checked_simplify<'a>(mut bb: Vec<BB<'a>>, f: Option<&TacFunc>) ->
     b.prev.clear(); // prev is filled afterwards, it's old value is not used in this function
     new.push(b);
   }
-
   for idx in 0..new.len() { // borrow checker...
     new[idx].next().iter().filter_map(|&x| x).for_each(|x| new[x as usize].prev.push(idx as u32));
   }
-
-  Some(new)
+  new
 }
\ No newline at end of file
diff --git a/tacopt/src/common_expr.rs b/tacopt/src/common_expr.rs
index b895f26..b6d388e 100644
--- a/tacopt/src/common_expr.rs
+++ b/tacopt/src/common_expr.rs
@@ -1,6 +1,6 @@
 use crate::{bb::{FuncBB, BB}, flow::{FlowElem, Flow, And}};
 use common::{BinOp, UnOp, HashMap, HashSet, Ref};
-use tac::{TacKind, Operand, MemHint, CallKind, Tac, TacIter, TacPayload};
+use tac::{Tac, Operand, MemHint, CallKind, TacNode, TacIter};
 use bitset::traits::*;
 
 pub fn work(f: &mut FuncBB) { WorkCtx::new(f).work(f); }
@@ -13,11 +13,11 @@ enum TacRhs {
 }
 
 impl TacRhs {
-  fn from_tac(kind: TacKind) -> Option<TacRhs> {
-    match kind {
-      TacKind::Bin { op, lr, .. } => Some(TacRhs::Bin(op, lr)),
-      TacKind::Un { op, r, .. } => Some(TacRhs::Un(op, r)),
-      TacKind::Load { base, off, .. } => { Some(TacRhs::Load(base, off)) }
+  fn from_tac(tac: Tac) -> Option<TacRhs> {
+    match tac {
+      Tac::Bin { op, lr, .. } => Some(TacRhs::Bin(op, lr)),
+      Tac::Un { op, r, .. } => Some(TacRhs::Un(op, r)),
+      Tac::Load { base, off, .. } => { Some(TacRhs::Load(base, off)) }
       _ => None
     }
   }
@@ -32,14 +32,14 @@ impl TacRhs {
 }
 
 // return whether this tac kill (obj, arr)
-fn mem_kill(kind: TacKind) -> (bool, bool) {
+fn mem_kill(kind: Tac) -> (bool, bool) {
   match kind {
-    TacKind::Store { hint, .. } => match hint {
+    Tac::Store { hint, .. } => match hint {
       MemHint::Immutable => (false, false),
       MemHint::Obj => (true, false),
       MemHint::Arr => (false, true),
     }
-    TacKind::Call { kind, .. } => match kind {
+    Tac::Call { kind, .. } => match kind {
       CallKind::Virtual(_, hint) | CallKind::Static(_, hint) => (hint.arg_obj, hint.arg_arr),
       _ => (false, false)
     }
@@ -53,7 +53,7 @@ struct WorkCtx<'a> {
   write2id: HashMap<u32, Box<[u32]>>,
   rhs2id: HashMap<TacRhs, u32>,
   // tac2id: tac to its TacRhs's id
-  tac2id: HashMap<Ref<'a, Tac<'a>>, u32>,
+  tac2id: HashMap<Ref<'a, TacNode<'a>>, u32>,
   // obj/arr: these TacRhs are Load, and they load from obj/arr
   obj: Box<[u32]>,
   arr: Box<[u32]>,
@@ -67,13 +67,12 @@ impl<'a> WorkCtx<'a> {
     let (mut obj, mut arr) = (HashSet::new(), HashSet::new());
     for b in &f.bb {
       for t in b.iter() {
-        let payload = t.payload.borrow();
-        let payload = &*payload;
-        if let Some(rhs) = TacRhs::from_tac(payload.kind) {
+        let tac = t.tac.get();
+        if let Some(rhs) = TacRhs::from_tac(tac) {
           let id = rhs2id.len() as u32;
           let id = *rhs2id.entry(rhs).or_insert(id);
           tac2id.insert(Ref(t), id);
-          if let TacKind::Load { hint, .. } = payload.kind {
+          if let Tac::Load { hint, .. } = tac {
             match hint {
               MemHint::Immutable => {}
               MemHint::Obj => { obj.insert(id); }
@@ -114,14 +113,13 @@ impl<'a> WorkCtx<'a> {
 
   fn compute_gen_kill(&self, b: &BB, gen: &mut [u32], kill: &mut [u32]) {
     for t in b.iter() {
-      let payload = t.payload.borrow();
-      let payload = &*payload;
-      if let Some(rhs) = TacRhs::from_tac(payload.kind).map(|rhs| self.rhs2id[&rhs]) { gen.bsset(rhs) }
-      if let Some(w) = payload.kind.rw().1.and_then(|w| self.write2id.get(&w)) {
+      let tac = t.tac.get();
+      if let Some(rhs) = TacRhs::from_tac(tac).map(|rhs| self.rhs2id[&rhs]) { gen.bsset(rhs) }
+      if let Some(w) = tac.rw().1.and_then(|w| self.write2id.get(&w)) {
         kill.bsor(w);
         gen.bsandn(w); // this has to be done after gen.bsset(rhs), because x = x + y doesn't gen x + y
       }
-      let (obj, arr) = mem_kill(payload.kind);
+      let (obj, arr) = mem_kill(tac);
       if obj {
         kill.bsor(&self.obj);
         gen.bsandn(&self.obj);
@@ -134,14 +132,15 @@ impl<'a> WorkCtx<'a> {
   }
 
   // all available expression with index = `rhs` be replaced by computing it to `new` and copy `new` to original dst
-  fn dfs(&mut self, idx: usize, f: &mut FuncBB<'a>, iter: impl IntoIterator<Item=&'a Tac<'a>>, rhs: u32, new: u32) {
+  fn dfs(&mut self, idx: usize, f: &mut FuncBB<'a>, iter: impl IntoIterator<Item=&'a TacNode<'a>>, rhs: u32, new: u32) {
     if self.vis[idx] { return; }
     self.vis[idx] = true;
     for t in iter {
       if self.tac2id.get(&Ref(t)) == Some(&rhs) {
-        let old = std::mem::replace(t.payload.borrow_mut().kind.rw_mut().1.expect("This tac with rhs must also have a lhs."), new);
-        let payload = TacPayload { kind: TacKind::Assign { dst: old, src: [Operand::Reg(new)] } }.into();
-        let copy = f.alloc.alloc(Tac { payload, prev: None.into(), next: None.into() });
+        let mut tac = t.tac.get();
+        let dst = std::mem::replace(tac.rw_mut().1.expect("This tac with rhs must also have a lhs."), new);
+        t.tac.set(tac); // the lhs of `tac` is changed to `new`
+        let copy = f.alloc.alloc(TacNode { tac: Tac::Assign { dst, src: [Operand::Reg(new)] }.into(), prev: None.into(), next: None.into() });
         f.bb[idx].insert_after(t, copy);
         return;
       }
@@ -154,23 +153,22 @@ impl<'a> WorkCtx<'a> {
 
   fn do_optimize(&mut self, idx: usize, f: &mut FuncBB<'a>, in_: &mut [u32]) {
     for (t_idx, t) in f.bb[idx].iter().enumerate() {
-      let mut payload = t.payload.borrow_mut();
-      let payload = &mut *payload;
-      let old_kind = payload.kind;
-      if let Some(rhs) = TacRhs::from_tac(payload.kind) {
+      let tac = t.tac.get();
+      if let Some(rhs) = TacRhs::from_tac(tac) {
         let rhs = self.rhs2id[&rhs];
         if in_.bsget(rhs) {
           let new = f.new_reg();
           for v in &mut self.vis { *v = false; }
+          // `prev` will iterate over all tac before `t` reversely
           let prev = TacIter::new(f.bb[idx].first, Some(t), t_idx + 1).rev().skip(1);
           self.dfs(idx, f, prev, rhs, new);
-          let w = payload.kind.rw().1.expect("The tac with rhs must also have a lhs.");
-          payload.kind = TacKind::Assign { dst: w, src: [Operand::Reg(new)] };
+          let dst = tac.rw().1.expect("The tac with rhs must also have a lhs.");
+          t.tac.set(Tac::Assign { dst, src: [Operand::Reg(new)] });
         }
       }
-      if let Some(rhs) = TacRhs::from_tac(old_kind).map(|rhs| self.rhs2id[&rhs]) { in_.bsset(rhs) }
-      if let Some(w) = old_kind.rw().1.and_then(|w| self.write2id.get(&w)) { in_.bsandn(w) }
-      let (obj, arr) = mem_kill(old_kind);
+      if let Some(rhs) = TacRhs::from_tac(tac).map(|rhs| self.rhs2id[&rhs]) { in_.bsset(rhs) }
+      if let Some(w) = tac.rw().1.and_then(|w| self.write2id.get(&w)) { in_.bsandn(w) }
+      let (obj, arr) = mem_kill(tac);
       if obj { in_.bsandn(&self.obj); }
       if arr { in_.bsandn(&self.arr); }
     }
diff --git a/tacopt/src/const_prop.rs b/tacopt/src/const_prop.rs
index 92da3c1..95275ce 100644
--- a/tacopt/src/const_prop.rs
+++ b/tacopt/src/const_prop.rs
@@ -1,5 +1,5 @@
-use crate::bb::{FuncBB, NextKind, checked_simplify};
-use tac::{TacKind, Operand};
+use crate::bb::{FuncBB, NextKind, simplify};
+use tac::{Tac, Operand};
 
 #[derive(Copy, Clone, Eq, PartialEq, Debug)]
 enum Value { Unk, Const(i32), Nac }
@@ -12,11 +12,11 @@ fn meet(x: Value, y: Value) -> Value {
   }
 }
 
-fn transfer(kind: TacKind, env: &mut [Value]) {
-  use TacKind::*;
+fn transfer(tac: Tac, env: &mut [Value]) {
+  use Tac::*;
   use Operand::*;
   use Value::{Const as C, Nac, Unk};
-  match kind {
+  match tac {
     Bin { op, dst, lr } => {
       let lr = match lr {
         [Const(l), Const(r)] => (C(l), C(r)),
@@ -40,13 +40,13 @@ fn transfer(kind: TacKind, env: &mut [Value]) {
     Load { dst, .. } => env[dst as usize] = Nac,
     // actually LoadStr and LoadVTbl won't give `dst` a Unk
     // but as long as the implementation is correct, `dst` can never be used in calculation, so giving them Unk is okay
-    LoadStr { dst, .. } | LoadVTbl { dst, .. } => env[dst as usize] = Unk,
+    LoadStr { dst, .. } | LoadVTbl { dst, .. } | LoadFunc { dst, .. } => env[dst as usize] = Unk,
     Param { .. } | Ret { .. } | Jmp { .. } | Label { .. } | Jif { .. } | Store { .. } => {}
   }
 }
 
 pub fn work(f: &mut FuncBB) {
-  let (n, each) = (f.bb.len(), f.max_reg as usize);
+  let (n, each) = (f.bb.len(), f.reg_num as usize);
   let mut flow = vec![Value::Unk; n * each];
   for i in 0..f.param_num as usize {
     flow[i] = Value::Nac; // flow[i] is in the entry bb, and setting them is enough
@@ -63,7 +63,7 @@ pub fn work(f: &mut FuncBB) {
     }
     for (idx, b) in f.bb.iter().enumerate() {
       let env = &mut flow[idx * each..(idx + 1) * each];
-      for t in b.iter() { transfer(t.payload.borrow().kind, env); }
+      for t in b.iter() { transfer(t.tac.get(), env); }
     }
     if flow != tmp { tmp.clone_from_slice(&flow); } else { break; }
   }
@@ -71,13 +71,14 @@ pub fn work(f: &mut FuncBB) {
   for (idx, b) in f.bb.iter_mut().enumerate() {
     let env = &mut flow[idx * each..(idx + 1) * each];
     for t in b.iter() {
-      let mut payload = t.payload.borrow_mut();
-      for r in payload.kind.rw_mut().0 {
+      let mut tac = t.tac.get();
+      for r in tac.rw_mut().0 {
         if let Operand::Reg(r1) = *r {
           if let Value::Const(r1) = env[r1 as usize] { *r = Operand::Const(r1); }
         }
       }
-      transfer(payload.kind, env);
+      transfer(t.tac.get(), env); // old value
+      t.tac.set(tac);
     }
     match &mut b.next {
       NextKind::Ret(Some(r)) => if let Operand::Reg(r1) = *r {
@@ -90,7 +91,5 @@ pub fn work(f: &mut FuncBB) {
       _ => {}
     }
   }
-  if flow_changed {
-    f.bb = checked_simplify(std::mem::replace(&mut f.bb, Vec::new()), None).unwrap();
-  }
-}
\ No newline at end of file
+  if flow_changed { f.bb = simplify(std::mem::replace(&mut f.bb, Vec::new())); }
+}
diff --git a/tacopt/src/copy_prop.rs b/tacopt/src/copy_prop.rs
index 5c37157..8b63338 100644
--- a/tacopt/src/copy_prop.rs
+++ b/tacopt/src/copy_prop.rs
@@ -1,6 +1,6 @@
 use crate::{bb::{FuncBB, BB}, flow::{FlowElem, Flow, And}};
 use common::{HashSet, HashMap, IndexSet};
-use tac::{TacKind, Operand};
+use tac::{Tac, Operand};
 use bitset::traits::*;
 
 pub fn work(f: &mut FuncBB) {
@@ -8,7 +8,7 @@ pub fn work(f: &mut FuncBB) {
   let mut copy2id = IndexSet::default();
   for b in &mut f.bb {
     for t in b.iter() {
-      if let TacKind::Assign { dst, src } = t.payload.borrow().kind {
+      if let Tac::Assign { dst, src } = t.tac.get() {
         if let Operand::Reg(src) = src[0] {
           if dst == src { // just delete it, doesn't even need propagation
             b.del(t);
@@ -39,15 +39,14 @@ pub fn work(f: &mut FuncBB) {
 
 fn compute_gen_kill(b: &BB, gen: &mut [u32], kill: &mut [u32], reg2copy: &HashMap<u32, Box<[u32]>>, copy2id: &IndexSet<(u32, u32)>) {
   for t in b.iter() {
-    let payload = t.payload.borrow();
-    let kind = &payload.kind;
-    kind.rw().1.map(|w| reg2copy.get(&w).map(|copy| {
+    let tac = t.tac.get();
+    tac.rw().1.map(|w| reg2copy.get(&w).map(|copy| {
       kill.bsor(copy);
       gen.bsandn(copy);
     }));
-    if let TacKind::Assign { dst, src } = kind {
+    if let Tac::Assign { dst, src } = tac {
       if let Operand::Reg(src) = src[0] {
-        gen.bsset(copy2id.get_full(&(*dst, src)).unwrap().0);
+        gen.bsset(copy2id.get_full(&(dst, src)).unwrap().0);
       }
     }
   }
@@ -63,17 +62,15 @@ fn do_optimize(b: &mut BB, in_: &mut [u32], reg2copy: &HashMap<u32, Box<[u32]>>,
     reg // failed to find any further copy, just return reg
   }
   for t in b.iter() {
-    let mut payload = t.payload.borrow_mut();
-    let kind = &mut payload.kind;
-    // save it, because may modify then
-    let old_assign = if let TacKind::Assign { dst, src } = kind {
-      if let Operand::Reg(src) = src[0] { Some((*dst, src)) } else { None }
-    } else { None };
+    let mut tac = t.tac.get();
     // modify the operand to do copy propagation
-    kind.rw_mut().0.iter_mut().for_each(|r| if let Operand::Reg(reg) = r { *reg = lookup(*reg, in_, copy2id) });
+    tac.rw_mut().0.iter_mut().for_each(|r| if let Operand::Reg(reg) = r { *reg = lookup(*reg, in_, copy2id) });
     // compute in_ for the next tac
-    kind.rw().1.map(|w| reg2copy.get(&w).map(|copy| in_.bsandn(copy)));
-    if let Some(a) = old_assign { in_.bsset(copy2id.get_full(&a).unwrap().0) }
+    tac.rw().1.map(|w| reg2copy.get(&w).map(|copy| in_.bsandn(copy)));
+    if let Tac::Assign { dst, src: [Operand::Reg(src)] } = t.tac.get() { // old value
+      in_.bsset(copy2id.get_full(&(dst, src)).unwrap().0)
+    }
+    t.tac.set(tac);
   }
   if let Some(r) = b.next_r_mut() { *r = lookup(*r, in_, copy2id); }
 }
\ No newline at end of file
-- 
2.24.0

