From a4f73a28c9443d7e44d38801975bd0ba77ab54a4 Mon Sep 17 00:00:00 2001
From: MashPlant <740678788@qq.com>
Date: Wed, 20 Nov 2019 16:35:37 +0800
Subject: [PATCH 2/3] remove Tac::LoadInt; some renaming

---
 codegen/src/mips_gen.rs  | 17 +++++++--------
 driver/src/test.rs       | 10 ++++++++-
 print/src/tac.rs         |  1 -
 tac/src/lib.rs           |  5 ++---
 tacgen/src/info.rs       | 10 ++++-----
 tacgen/src/lib.rs        | 47 ++++++++++++++++++++--------------------
 tacopt/src/const_prop.rs |  1 -
 7 files changed, 48 insertions(+), 43 deletions(-)

diff --git a/codegen/src/mips_gen.rs b/codegen/src/mips_gen.rs
index eee847e..495e394 100644
--- a/codegen/src/mips_gen.rs
+++ b/codegen/src/mips_gen.rs
@@ -142,9 +142,9 @@ impl<'a: 'b, 'b> FuncGen<'a, 'b> {
       if !(b1.prev.is_empty() || (b1.prev.len() == 1 && b1.prev[0] + 1 == idx as u32)) {
         b2.push(AsmTemplate::Label(format!("{}_L{}:", self.name, idx + 1)));
       }
-      let mut arg_cnt = 0;
+      let mut arg_num = 0;
       for t in b1.iter() {
-        self.select_inst(t.tac.get(), &mut b2, &mut arg_cnt);
+        self.select_inst(t.tac.get(), &mut b2, &mut arg_num);
       }
       // generate ret/jmp/..., and return the `next` by the way
       let next = self.build_next(idx as u32, f.bb.len() as u32 + 1, b1.next, &mut b2);
@@ -266,7 +266,7 @@ impl FuncGen<'_, '_> {
 }
 
 impl FuncGen<'_, '_> {
-  fn select_inst(&mut self, t: Tac, b: &mut Vec<AsmTemplate>, arg_cnt: &mut u32) {
+  fn select_inst(&mut self, t: Tac, b: &mut Vec<AsmTemplate>, arg_num: &mut u32) {
     use AsmTemplate::*;
     match t {
       Tac::Bin { op, dst, lr } => {
@@ -290,11 +290,11 @@ impl FuncGen<'_, '_> {
       Tac::Assign { dst, src } => self.build_mv(vreg(dst), src[0], b),
       Tac::Param { src } => {
         let src = self.build_operand(src[0], b);
-        match ARG.nth(*arg_cnt as usize) {
+        match ARG.nth(*arg_num as usize) {
           Some(a) => b.push(Mv(Reg::PreColored(a), src)),
-          None => b.push(Sw(src, mreg(SP), Imm::Int(*arg_cnt as i32 * WORD_SIZE))),
+          None => b.push(Sw(src, mreg(SP), Imm::Int(*arg_num as i32 * WORD_SIZE))),
         }
-        *arg_cnt += 1;
+        *arg_num += 1;
       }
       Tac::Call { dst, kind } => {
         let called = match kind {
@@ -312,9 +312,9 @@ impl FuncGen<'_, '_> {
         if called {
           // once it is really a function call, ch_param_num should grows from 4
           // because calling convention says the first 4 argument should have their slots on the stack
-          self.ch_param_num = self.ch_param_num.max(*arg_cnt).max(4);
+          self.ch_param_num = self.ch_param_num.max(*arg_num).max(4);
         }
-        *arg_cnt = 0;
+        *arg_num = 0;
         if let Some(dst) = dst { b.push(Mv(vreg(dst), mreg(V0))); }
       }
       Tac::Load { dst, base, off, .. } => {
@@ -325,7 +325,6 @@ impl FuncGen<'_, '_> {
         let (src, base) = (self.build_operand(src_base[0], b), self.build_operand(src_base[1], b));
         b.push(Sw(src, base, Imm::Int(off)));
       }
-      Tac::LoadInt { dst, i } => b.push(AsmTemplate::Li(vreg(dst), Imm::Int(i))),
       Tac::LoadStr { dst, s } => b.push(AsmTemplate::La(vreg(dst), format!("_STRING{}", s))),
       Tac::LoadVTbl { dst, v } => b.push(AsmTemplate::La(vreg(dst), format!("_{}", self.program.vtbl[v as usize].class))),
       Tac::LoadFunc { dst, f } => b.push(AsmTemplate::La(vreg(dst), self.program.func[f as usize].name.clone())),
diff --git a/driver/src/test.rs b/driver/src/test.rs
index 4c0e570..467abd3 100644
--- a/driver/src/test.rs
+++ b/driver/src/test.rs
@@ -1,7 +1,15 @@
 use driver::*;
 
 fn main() {
-  for result in test_all("testcase/S1", Pa::Pa1a).unwrap() {
+  for result in test_all("testcase/S3", Pa::Pa3).unwrap() {
     println!("{:?}", result);
   }
+ //   eprintln!("{:?}", compile(r#"
+ // class Main {
+ //  static void f(class Main m) {}
+ //  static void main() {
+ //    f(Main)  ;
+ //  }
+ // }
+ //   "#, &Alloc::default(), Pa::Pa2.to_cfg() ));
 }
diff --git a/print/src/tac.rs b/print/src/tac.rs
index 80bcd3b..7819b12 100644
--- a/print/src/tac.rs
+++ b/print/src/tac.rs
@@ -47,7 +47,6 @@ pub fn write_tac(t: Tac, pr: &TacProgram, p: &mut IndentPrinter) {
     Label { label } => write!(p, "_L{}:", label),
     Load { dst, base, off, .. } => write!(p, "_T{} = *({:?} {} {})", dst, base[0], if off >= 0 { '+' } else { '-' }, off.abs()),
     Store { src_base, off, .. } => write!(p, "*({:?} {} {}) = {:?}", src_base[1], if off >= 0 { '+' } else { '-' }, off.abs(), src_base[0]),
-    LoadInt { dst, i } => write!(p, "_T{} = {}", dst, i),
     LoadStr { dst, s } => write!(p, "_T{} = \"{}\"", dst, pr.str_pool.get_index(s as usize).unwrap()),
     LoadVTbl { dst, v } => write!(p, "_T{} = VTBL<_{}>", dst, pr.vtbl[v as usize].class),
     LoadFunc { dst, f } => write!(p, "_T{} = FUNC<{}>", dst, pr.func[f as usize].name),
diff --git a/tac/src/lib.rs b/tac/src/lib.rs
index 330a1a8..9bf9a86 100644
--- a/tac/src/lib.rs
+++ b/tac/src/lib.rs
@@ -79,7 +79,6 @@ pub enum Tac {
   // for Store: Immutable => it doesn't affect any Load result, Obj => correspond to Obj in Load, Arr => like Obj
   Load { dst: u32, base: [Operand; 1], off: i32, hint: MemHint },
   Store { src_base: [Operand; 2], off: i32, hint: MemHint },
-  LoadInt { dst: u32, i: i32 },
   // s: the index in TacProgram::str_pool
   LoadStr { dst: u32, s: u32 },
   // v: the index in TacProgram::vtbl
@@ -101,7 +100,7 @@ impl Tac {
       Jmp { .. } | Label { .. } => (&[], None),
       Jif { cond, .. } => (cond, None),
       Store { src_base, .. } => (src_base, None),
-      LoadInt { dst, .. } | LoadStr { dst, .. } | LoadVTbl { dst, .. } | LoadFunc { dst, .. } => (&[], Some(*dst)),
+      LoadStr { dst, .. } | LoadVTbl { dst, .. } | LoadFunc { dst, .. } => (&[], Some(*dst)),
     }
   }
 
@@ -119,7 +118,7 @@ impl Tac {
       Jmp { .. } | Label { .. } => (&mut [], None),
       Jif { cond, .. } => (cond, None),
       Store { src_base, .. } => (src_base, None),
-      LoadInt { dst, .. } | LoadStr { dst, .. } | LoadVTbl { dst, .. } | LoadFunc { dst, .. } => (&mut [], Some(dst)),
+      LoadStr { dst, .. } | LoadVTbl { dst, .. } | LoadFunc { dst, .. } => (&mut [], Some(dst)),
     }
   }
 }
diff --git a/tacgen/src/info.rs b/tacgen/src/info.rs
index 6d1455e..1029c42 100644
--- a/tacgen/src/info.rs
+++ b/tacgen/src/info.rs
@@ -4,8 +4,8 @@ use common::IndexMap;
 // these structs are used in tacgen to keep some intermediate information
 
 pub struct VarInfo {
-  // for a VarDef in class, it is the offset in object pointer
-  // for a VarDef in function, it is the virtual register number
+  // if the var is a VarDef in class, `off` is the offset in object pointer
+  // if the var is a VarDef in function, `off` is a virtual register number
   pub off: u32,
 }
 
@@ -13,13 +13,13 @@ pub struct FuncInfo {
   // the offset in vtbl
   // vtbl[0] = parent, vtbl[1] = class name
   pub off: u32,
-  // which function it is in TacProgram
+  // which function it is in TacProgram (index in TacProgram::func)
   pub idx: u32,
 }
 
 pub struct ClassInfo<'a> {
-  pub field_cnt: u32,
-  // which vtbl it's vtbl is in TacProgram
+  pub field_num: u32,
+  // which vtbl it's vtbl is in TacProgram (index in TacProgram::vtbl)
   pub idx: u32,
   pub vtbl: IndexMap<&'a str, &'a FuncDef<'a>>,
 }
\ No newline at end of file
diff --git a/tacgen/src/lib.rs b/tacgen/src/lib.rs
index d6ca9a0..ab0235f 100644
--- a/tacgen/src/lib.rs
+++ b/tacgen/src/lib.rs
@@ -8,8 +8,9 @@ use crate::info::*;
 
 #[derive(Default)]
 struct TacGen<'a> {
+  // `reg_num` and `label_num` are manually set at the beginning of every function
   reg_num: u32,
-  label_cnt: u32,
+  label_num: u32,
   loop_stk: Vec<u32>,
   // Id & Index will behave differently when they are the lhs of an assignment
   // cur_assign contains the current assign rhs operand, or None if the current handling expr doesn't involve in assign
@@ -54,7 +55,7 @@ impl<'a> TacGen<'a> {
           }
           // these regs are occupied by parameters
           self.reg_num = fu.param.len() as u32 + this;
-          self.label_cnt = 0;
+          self.label_num = 0;
           let name = if Ref(c) == Ref(p.main.get().unwrap()) && fu.name == MAIN_METHOD { MAIN_METHOD.into() } else { format!("_{}.{}", c.name, fu.name) };
           let mut f = TacFunc::empty(alloc, name, self.reg_num);
           self.block(&fu.body, &mut f);
@@ -227,9 +228,9 @@ impl<'a> TacGen<'a> {
       IntLit(i) => Const(*i),
       BoolLit(b) => Const(*b as i32),
       StringLit(s) => {
-        let s1 = self.reg();
-        f.push(LoadStr { dst: s1, s: self.define_str(s) });
-        Reg(s1)
+        let dst = self.reg();
+        f.push(LoadStr { dst, s: self.define_str(s) });
+        Reg(dst)
       }
       NullLit(_) => Const(0),
       Call(c) => {
@@ -354,27 +355,27 @@ impl<'a> TacGen<'a> {
 
   fn reg(&mut self) -> u32 { (self.reg_num, self.reg_num += 1).0 }
 
-  fn label(&mut self) -> u32 { (self.label_cnt, self.label_cnt += 1).0 }
+  fn label(&mut self) -> u32 { (self.label_num, self.label_num += 1).0 }
 
   // if you don't need to modify the returned register, it is more recommended to use Const(i)
   fn int(&mut self, i: i32, f: &mut TacFunc<'a>) -> u32 {
-    let ret = self.reg();
-    f.push(LoadInt { dst: ret, i });
-    ret
+    let dst = self.reg();
+    f.push(Tac::Assign { dst, src: [Const(i)] });
+    dst
   }
 
   // perform an intrinsic call, return value is Some if this intrinsic call has return value
   fn intrinsic(&mut self, i: Intrinsic, f: &mut TacFunc<'a>) -> Option<u32> {
-    let ret = if i.has_ret() { Some(self.reg()) } else { None };
-    f.push(Tac::Call { dst: ret, kind: CallKind::Intrinsic(i) });
-    ret
+    let dst = if i.has_ret() { Some(self.reg()) } else { None };
+    f.push(Tac::Call { dst, kind: CallKind::Intrinsic(i) });
+    dst
   }
 
   // read the length of `arr` (caller should guarantee `arr` is really an array)
   fn length(&mut self, arr: Operand, f: &mut TacFunc<'a>) -> Operand {
-    let ret = self.reg();
-    f.push(Load { dst: ret, base: [arr], off: -(INT_SIZE as i32), hint: MemHint::Immutable });
-    Reg(ret)
+    let dst = self.reg();
+    f.push(Load { dst, base: [arr], off: -(INT_SIZE as i32), hint: MemHint::Immutable });
+    Reg(dst)
   }
 
   // re is short for for runtime error; this function prints a message and call halt
@@ -412,10 +413,10 @@ impl<'a> TacGen<'a> {
   // this function relies on the fact that no cyclic inheritance exist, which is guaranteed in typeck
   fn resolve_field(&mut self, c: &'a ClassDef<'a>) {
     if !self.class_info.contains_key(&Ref(c)) {
-      let (mut field_cnt, mut vtbl) = if let Some(p) = c.parent_ref.get() {
+      let (mut field_num, mut vtbl) = if let Some(p) = c.parent_ref.get() {
         self.resolve_field(p);
         let p = &self.class_info[&Ref(p)];
-        (p.field_cnt, p.vtbl.clone())
+        (p.field_num, p.vtbl.clone())
       } else { (1, IndexMap::default()) };
       for f in &c.field {
         match f {
@@ -433,25 +434,25 @@ impl<'a> TacGen<'a> {
             self.func_info.insert(Ref(f), FuncInfo { off: 0, idx: 0 });
           }
           FieldDef::VarDef(v) => {
-            self.var_info.insert(Ref(v), VarInfo { off: field_cnt });
-            field_cnt += 1;
+            self.var_info.insert(Ref(v), VarInfo { off: field_num });
+            field_num += 1;
           }
         }
       }
-      self.class_info.insert(Ref(c), ClassInfo { field_cnt, idx: 0, vtbl });
+      self.class_info.insert(Ref(c), ClassInfo { field_num, idx: 0, vtbl });
     }
   }
 
   fn build_new(&mut self, c: &'a ClassDef<'a>, alloc: &'a Arena<TacNode<'a>>) -> TacFunc<'a> {
     self.reg_num = 0;
-    let ClassInfo { field_cnt, idx, .. } = self.class_info[&Ref(c)];
+    let ClassInfo { field_num, idx, .. } = self.class_info[&Ref(c)];
     let mut f = TacFunc::empty(alloc, format!("_{}._new", c.name), 0);
-    f.push(Param { src: [Const(field_cnt as i32 * INT_SIZE)] });
+    f.push(Param { src: [Const(field_num as i32 * INT_SIZE)] });
     let ret = self.intrinsic(_Alloc, &mut f).unwrap();
     let vtbl = self.reg();
     f.push(LoadVTbl { dst: vtbl, v: idx });
     f.push(Store { src_base: [Reg(vtbl), Reg(ret)], off: 0, hint: MemHint::Immutable });
-    for i in 1..field_cnt {
+    for i in 1..field_num {
       f.push(Store { src_base: [Const(0), Reg(ret)], off: i as i32 * INT_SIZE, hint: MemHint::Obj });
     }
     f.push(Ret { src: Some([Reg(ret)]) });
diff --git a/tacopt/src/const_prop.rs b/tacopt/src/const_prop.rs
index 95275ce..378fac7 100644
--- a/tacopt/src/const_prop.rs
+++ b/tacopt/src/const_prop.rs
@@ -36,7 +36,6 @@ fn transfer(tac: Tac, env: &mut [Value]) {
     },
     Assign { dst, src } => env[dst as usize] = match src[0] { Const(r) => C(r), Reg(r) => env[r as usize] },
     Call { dst, .. } => if let Some(dst) = dst { env[dst as usize] = Nac }
-    LoadInt { dst, i } => env[dst as usize] = C(i),
     Load { dst, .. } => env[dst as usize] = Nac,
     // actually LoadStr and LoadVTbl won't give `dst` a Unk
     // but as long as the implementation is correct, `dst` can never be used in calculation, so giving them Unk is okay
-- 
2.24.0

